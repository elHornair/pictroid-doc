<!DOCTYPE html>
<html>
<head>
    <title>Dokumentation Pictroid</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="css/master.css" />
    <script type="text/javascript" src="js/main.js"></script>
</head>

<body>

<div class="dummy"></div>
<div class="frontpage">
    <h1>Pictroid</h1>
    <h2>Programmieren mit Bildern</h2>
    <p>Seminararbeit im Rahmen von "Syntax und Semantik" Im Studiengang Informatik an der ZHAW
       von Alain Horner - Frühjahr 2013</p>
</div>

<h1>Inhaltsverzeichnis</h1>
<ol id="toc">
</ol>

<div id="content">

    <div class="chapter">
        <h1>Projektbeschreibung</h1>

        <h2>Ausgangslage</h2>
        <p>
            Programmieranfänger sind mit in der Praxis verwendeten Programmiersprachen oft überfordert.
            Einerseits sind diese Sprachen sehr komplex, andererseits die Interpreter/Compiler äusserst pingelig.
            Aus eigener Erfahrung verbringt man zu Beginn deshalb viel Zeit damit, sich mit fehlenden Semikola
            und der korrekten Schreibweise von Befehlen herumzuschlagen. Mit einer Programmiersprache, die sich an
            den Bedürfnissen von Programmieranfängern orientiert, könnte deshalb der Einstieg in die Programmierung
            erleichtert werden.
        </p>

        <h2>Ziel der Arbeit</h2>
        <p>
            Das Ziel der Arbeit ist die Entwicklung einer bilderbasierten Programmiersprache und einer Anwendung dieser
            Sprache.
        </p>

        <h2>Aufgabenstellung</h2>
        <p>
            Es soll eine einfache Programmiersprache entwickelt werden, in der Anweisungen aus Bildern bestehen.
            Die Sprache soll es Programmiereinsteigern erlauben, mit Hilfe von Bildern einfachen Code zu "schreiben".
            So sollen diese ein grundlegendes Verständnis für das Entwickeln und Interpretieren von Programmcode erlangen.
            Der Student kann so Erfahrung sammeln im Entwickeln und Interpretieren einer Programmiersprache. Die Aufgabe
            verlangt zudem ein selbständiges Erarbeiten und Verstehen der Backus-Naur-Form und weiterer benötigter
            Konzepte.
        </p>

        <h2>Erwartete Resultate</h2>
        <p>
            Nach Abschluss der Arbeit sollen folgende Resultate vorliegen:
        </p>
        <ul>
            <li>Definition einer einfachen Programmiersprache in der Backus-Naur-Form</li>
            <li>Verifizier: Gibt an, ob syntaktisch<span class="footnote">Siehe Glossar</span> korrektes Programm
                vorliegt</li>
            <li>Interpreter: Arbeitet korrektes Programm schrittweise durch</li>
            <li>
                Es soll eine Anwedung entwickelt werden, die folgende Anforderungen erfüllt:
                <ul>
                    <li>Der Benutzer kann mit Bildern ein Programm zusammenstellen</li>
                    <li>Der Benutzer kann sein Programm mittels Drag'n'Drop<span class="footnote">Siehe
                        Glossar</span> bearbeiten</li>
                    <li>Der Benutzer kann ein erstelltes Programm ausführen lassen</li>
                    <li>Ein Roboter kann ein Programm interpretieren und die entsprechenden Schritte ausführen</li>
                    <li>Der Roboter hat ein Zielfeld zu erreichen und stoppt automatisch,
                        wenn das Ziel erreicht ist</li>
                    <li>Die Anwendung erkennt Syntaxfehler und signalisiert diese dem Benutzer</li>
                    <li>Es stehen drei Levels zur Verfügung, in denen der Benutzer das Programmieren üben kann</li>
                </ul>
            </li>
            <li>Dokumentation der wesentlichen Arbeitsschritte</li>
        </ul>

        <h2>Einschränkungen</h2>
        <p>
            Für die vorliegende Arbeit gelten folgende Einschränkungen:
        </p>
        <ul>
            <li>Es soll nicht zwingend eine generische Programmiersprache entwickelt werden. Deshalb besteht nicht der
                Anspruch, dass die zu entwickelnde Sprache turing-vollständig<span class="footnote">Siehe Glossar</span>
                ist.</li>
            <li>Bei der zu entwickelten Anwendung handelt es sich um einen Prototypen. Die Anwendung kann deshalb in der
                Benutzerfreundlichkeit und der grafischen Aufmachung Lücken aufweisen. Der Prototyp soll lediglich das
                Funktionsprinzip demonstrieren.</li>
        </ul>

        <h2>Abgrenzung zu RoboWar</h2>
        <p>
            <i>RoboWar</i><span class="footnote source">
                Kevin Hertzberg (2004), RoboWar<span class="additional">, Abgerufen am 11.05.2013 von
                http://robowar.sourceforge.net/RoboWar5/index.html</span>
            </span> ist ein Strategiespiel für mehrere Spieler, in welchem die Spieler jeweils einen Kampfroboter
            steuern. Oberstes Ziel ist dabei das Zerstören der anderen Roboter. RoboWar definiert eine eigene
            Programmiersprache. Mit Instruktionen dieser Sprache werden die Roboter von den Spielern programmiert.
        </p>
        <p>
            Die hier zu entwickelnde Sprache, bzw. der hier zu entwickelnde Prototyp unterscheidet sich von RoboWar in
            folgenden Punkten:
        </p>
        <ul>
            <li>Es soll eine Lernsprache, bzw. eine Lernanwendung entwickelt werden: Auf spielerische Weise soll das
                Programmieren entdeckt werden. RoboWar ist ein Spiel.</li>
            <li>Während sich die zu entwickelnde Sprache an Programmieranfänger richtet, sind für das Spielen von
                RoboWar fortgeschrittene Programmierkenntnisse notwendig.</li>
            <li>Die zu entwickelnde Sprache wird für Einzelspieler konzipiert.</li>
            <li>Während in RoboWar textueller Code zur Programmierung der Roboter verwendet wird, werden
                hier Progamme mit Hilfe von Bildern formuliert.</li>
            <li>Die hier verwendete Sprache soll deutlich weniger Instruktionen besitzen, als die RoboWar-Sprache
                <span class="footnote source">
                    RoboWiki (2008), Instruction Reference<span class="additional">, Abgerufen am 11.05.2013 von
                    http://robowar.wikia.com/wiki/Instruction_Reference</span>
                    </span>
            </li>
            <li>Das Ziel in der zu entwickelnden Anwendung ist das Erreichen des Zielfeldes. Bei RoboWar sollen die
                feindlichen Roboter zerstört werden.</li>
        </ul>
    </div>

    <div class="chapter">
        <h1>Projektplanung</h1>

        <h2>Zeitlicher Rahmen</h2>
        <p>
            Der Kurs wird mit zwei ECTS Punkten honoriert, was einem Aufwand von 50-60 Stunden gleichkommt.
            Davon werden zehn Stunden für Kickoff-Meeting, Koordination und Präsentation abgezogen.
            Somit verbleiben 40-50 Stunden für die Bearbeitung des Themas. Die zur Verfügung stehende Zeit wird wie folgt
            für die Teilarbeiten eingeplant:
        </p>
        <ul>
            <li>Recherchen, Einlesen in das Thema: 5 Stunden</li>
            <li>Entwicklung Sprache: 5 Stunden</li>
            <li>Entwicklung Verifizier/Interpreter: 10 Stunden</li>
            <li>Entwicklung Prototyp: 15 Stunden</li>
            <li>Dokumentation: 15 Stunden</li>
        </ul>

        <h2>Meilensteine</h2>
        <p>
            Folgende Termine sind vorgegeben:
        </p>
        <ul>
            <li>20. März 2013: Kickoff-Meeting</li>
            <li>27. März 2013: Festlegung des Themas</li>
            <li>05. Juni 2013: Abgabe der Seminararbeit</li>
            <li>12. Juni 2013: Präsentation der Seminararbeit</li>
        </ul>
    </div>

    <div class="chapter">
        <h1>Entwicklung der Sprache</h1>

        <h2>Grundlegende Überlegungen</h2>
        <p>
            Die zu Entwickelnde Sprache wird <i>Pictroid</i> genannt. Pictroid setzt sich aus den beiden englischen
            Wörtern <i>picture</i> und <i>android</i> zusammen. Die Bezeichnung ist deshalb passend, weil mit
            Bildern<span class="footnote">Englisch: Picture</span> ein Roboter<span class="footnote">Englisch:
            Android</span> programmiert werden soll. Das Wort Pictroid wird auch benutzt, um den im Prototyp
            verwendeten Roboter zu bezeichnen.
        </p>
        <p>
            Gemäss den obigen Zielsetzungen soll die Pictroid-Sprache möglichst einfach sein. Es wurde deshalb überlegt,
            welche wichtigen Programmierkonstrukte für einen Einsteiger fassbar sind und trotzdem ein mächtiges Werkzeug
            in der Programmierung darstellen. Dabei wurden die folgenden drei Konstrukte herausgefiltert:
        </p>
        <ul>
            <li>Anweisungen: Anweisungen sind das wohl wichtigste aller Programmierkonstrukte. Damit können dem
                Computer (bzw. dem Roboter) konkrete Schritte "befohlen" werden. Dieses Konzept ist auch für
                Einsteiger schnell zu verstehen: Ich befehle etwas und der Computer führt es aus.</li>
            <li>Bedingungen: Beim Schreiben eines noch so einfachen Programms kommt man schnell in eine Situation, in
                der man eine Fallunterscheidung vornehmen will. Das Konzept ist deshalb einfach zu verstehen, weil
                vermutlich alle Programmieranfänger Bedingungen aus dem Alltag kennen: Wenn die Ampel rot ist, warte
                ich, wenn die Ampel grün ist, laufe ich.</li>
            <li>Schleifen: Eine wichtige frühe Erkenntnis auf dem frühen Weg zum Programierer ist, dass nicht jede Anweisung
                einzeln erteilt werden muss. Der Computer kann angewiesen werden, Anweisungen zu wiederholen.</li>
        </ul>
        <p>Folgende Konstrukte stellen ebenfalls wichtige Konzepte der Programmierung dar, sollen aber der Einfachheit
            halber nicht Teil der Pictroid-Sprache sein:
        </p>
        <ul>
            <li>Funktionen: Sobald grössere Programme geschrieben werden, entsteht der Wunsch, Code-Sequenzen
                gruppiert abzuspeichern und so wiederverwendbar zu machen. Da mit Pictroid nur sehr kleine Programme
                geschrieben werden sollen, kann jedoch darauf verzichtet werden.</li>
            <li>Ausgabe: Abhängig von der Art des zu lösenden Problems kann eine Rückmeldung des Computers
                unumgänglich sein (z.B. bei einer mathematischen Berechnung). Für Pictroid kann aber darauf verzichtet
                werden, da sich auch ohne eine Ausgabemöglichkeit einfache Programme implementieren lassen.</li>
        </ul>
        <p>
            Es ist vorstellbar, dass diese Konzepte zu einem späteren Zeitpunkt in die Sprache integriert werden.
        </p>

        <h2>Die Sprache Pictroid</h2>
        <p>
            Aufgrund der obigen Überlegungen wurden folgende Symbole für die Pictroid-Sprache definiert. Es wurde darauf
            geachtet, die Symbole so auszuwählen, dass ihre jeweilige Bedeutung leicht damit assoziiert werden kann. Die
            verschiedenen Farben sollen dabei die Ähnlichkeit der Symbole unterstreichen.
        </p>
        <table class="symbols">
            <caption>Pictroid-Symbole mit Beschreibung</caption>
            <tr>
                <th>Symbol</th>
                <th>Semantische Bedeutung<span class="footnote">Siehe Glossar</span></th>
            </tr>
            <tr>
                <td><span class="symbol left"></span></td>
                <td>Weist den Roboter an, sich nach links zu bewegen, bzw. sich nach links zu drehen.</td>
            </tr>
            <tr>
                <td><span class="symbol right"></span></td>
                <td>Weist den Roboter an, sich nach rechts zu bewegen, bzw. sich nach rechts zu drehen.</td>
            </tr>
            <tr>
                <td><span class="symbol up"></span></td>
                <td>Weist den Roboter an, sich nach oben zu bewegen, bzw. sich nach oben zu drehen.</td>
            </tr>
            <tr>
                <td><span class="symbol down"></span></td>
                <td>Weist den Roboter an, sich nach unten zu bewegen, bzw. sich nach unten zu drehen.</td>
            </tr>
            <tr>
                <td><span class="symbol stone"></span></td>
                <td>Steht für einen Stein.</td>
            </tr>
            <tr>
                <td><span class="symbol field"></span></td>
                <td>Steht für ein leeres Feld.</td>
            </tr>
            <tr>
                <td><span class="symbol condition"></span></td>
                <td>Markiert den Beginn einer Bedingung.</td>
            </tr>
            <tr>
                <td><span class="symbol endcondition"></span></td>
                <td>Markiert das Ende einer Bedingung.</td>
            </tr>
            <tr>
                <td><span class="symbol repeat"></span></td>
                <td>Markiert den Beginn einer Schleife.</td>
            </tr>
            <tr>
                <td><span class="symbol endrepeat"></span></td>
                <td>Markiert das Ende einer Schleife.</td>
            </tr>
            <tr>
                <td><span class="symbol two"></span></td>
                <td>Steht für die Zahl <i>zwei</i>. Entsprechend werden Symbole für die Zahlen <i>drei</i> bis
                    <i>neun</i> definiert. Diese sind hier aus Platzgründen nicht aufgelistet.</td>
            </tr>
            <tr>
                <td><span class="symbol infinite"></span></td>
                <td>Steht für eine unendlich grosse Zahl.</td>
            </tr>
        </table>
        <p>
            Pictroid-Bedingungen werden wie folgt formuliert:
        </p>
        <table class="symbols">
            <caption>Bedingungen in Pictroid</caption>
            <tr>
                <th>Symbol</th>
                <th>Erklärung</th>
            </tr>
            <tr>
                <td><span class="symbol condition"></span></td>
                <td>Markiert den Beginn der Bedinung.</td>
            </tr>
            <tr>
                <td><span class="symbol stone"></span></td>
                <td>Definiert, unter welcher Bedingung der Bedingungskörper ausgeführt wird. Die Bedingung bezieht sich
                    immer auf das Feld, das der Roboter betreten würde, wenn er ein Feld geradeaus gehen würde.
                    Alternativ kann das Symbol für ein leeres Feld verwendet werden.</td>
            </tr>
            <tr>
                <td><span class="symbol"></span></td>
                <td>Körper der Bedingung. Hier dürfen beliebige Anweisungen stehen (auch weitere Bedingungen und
                    Schleifen).</td>
            </tr>
            <tr>
                <td><span class="symbol endcondition"></span></td>
                <td>Markiert das Ende der Bedinung.</td>
            </tr>
        </table>
        <p>
            Die Pictroid-Symbole dürfen wie folgt zu Schleifen zusammengefügt werden:
        </p>
        <table class="symbols">
            <caption>Schleifen in Pictroid</caption>
            <tr>
                <th>Symbol</th>
                <th>Erklärung</th>
            </tr>
            <tr>
                <td><span class="symbol repeat"></span></td>
                <td>Markiert den Beginn der Schleife.</td>
            </tr>
            <tr>
                <td><span class="symbol two"></span></td>
                <td>Definiert die Anzahl der auszuführenden Wiederholungen. Alternativ können die Zahlen <i>drei</i>
                    bis <i>neun</i> oder das Symbol für Unendlichkeit verwendet werden.</td>
            </tr>
            <tr>
                <td><span class="symbol"></span></td>
                <td>Körper der Schleife. Hier dürfen beliebige Anweisungen stehen (auch weitere Schleifen und
                    Bedingungen).</td>
            </tr>
            <tr>
                <td><span class="symbol endrepeat"></span></td>
                <td>Markiert das Ende der Schleife.</td>
            </tr>
        </table>
        <p>
            Bedingungen und Schleifen dürfen beliebig ineinander verschachtelt werden. Die Anweisungen zur
            Richtungsänderung dürfen in beliebiger Anzahl ausserhalb von Schleifen und Bedingungen, oder in deren Körper
            vorkommen. Alle anderen als die hier aufgeführten Symbole und Kombinationen sind syntaktisch falsch.
        </p>

        <h2>Pictroid in EBNF-Notation</h2>
        <p>
            Nachdem die grundsätzliche Funktionsweise von Pictroid erarbeitet wurde muss die Sprache formal definiert
            werden. Dazu wird die EBNF-Notation<span class="footnote source">
                ISO (1996), Extended BNF<span class="additional">, Abgerufen am 28.04.2013 von
                http://standards.iso.org/ittf/licence.html</span>
            </span> verwendet. Der Zweck der EBNF-Notation ist es, kontextfreie Grammatiken einheitlich zu beschreiben.
            <span class="footnote source">
                Noam Chomsky (1956), Three models for the description of language<span class="additional">,
                erschienen bei IEEE, ISSN 0096-1000</span>
            </span> Jede Programmiersprache kann als kontextfreie Grammatik aufgefasst werden, also auch Pictroid.
        </p>
        <p>
            In der EBNF-Notation werden einerseits <i>Terminalsymbole</i> beschrieben. Diese umfassen alle Zeichen, die
            im Programmcode der Sprache vorkommen dürfen. Andererseits werden in der EBNF-Notation <i>Nichtterminale</i>
            definiert, die Platzhalter darstellen. Mithilfe von <i>Produktionsregeln</i> können Nichtterminale
            in beliebig lange Folgen von Terminalen und weiteren Nichtterminalen umgewandelt werden. Produktionsregeln
            bestehen immer aus dem linken Teil (dem Nichtterminal), einem Gleichheitszeichen, dem rechten Teil
            (der Produktion) und einem abschliessenden Strichpunkt.
            In der Produktion sind Aneinanderreihungen (dargestellt durch Komma) und Alternativen
            (dargestellt durch vertikalen Strich) von Symbolen erlaubt. Optionale Symbole oder Symbolfolgen werden in
            eckige Klammern gefasst. Symbole oder Symbolfolgen, die beliebig oft (auch nie) wiederholt werden dürfen,
            werden in geschweifte Klammern gefasst. Einfache Klammern dienen der Gruppierung von Symbolfolgen.
        </p>
        <p>
            Um die Lesbarkeit der Sprache in der EBNF-Notation zu erhöhen, werden die grafischen Symbole durch kurze
            Texte ersetzt. Die verwendeten Texte entsprechen wie folgt den zuvor definierten Symbolen:
        </p>
        <table class="symbols">
            <caption>Pictroid-Symbole und entsprechende Ersatztexte</caption>
            <tr>
                <th>Symbol</th>
                <th>Ersatztext</th>
                <th>Symbol</th>
                <th>Ersatztext</th>
            </tr>
            <tr>
                <td><span class="symbol left"></span></td>
                <td>left</td>
                <td><span class="symbol right"></span></td>
                <td>right</td>
            </tr>
            <tr>
                <td><span class="symbol up"></span></td>
                <td>up</td>
                <td><span class="symbol down"></span></td>
                <td>down</td>
            </tr>
            <tr>
                <td><span class="symbol stone"></span></td>
                <td>stone</td>
                <td><span class="symbol field"></span></td>
                <td>field</td>
            </tr>
            <tr>
                <td><span class="symbol condition"></span></td>
                <td>condition</td>
                <td><span class="symbol endcondition"></span></td>
                <td>endcondition</td>
            </tr>
            <tr>
                <td><span class="symbol repeat"></span></td>
                <td>repeat</td>
                <td><span class="symbol endrepeat"></span></td>
                <td>endrepeat</td>
            </tr>
        </table>

        <p>
            Die numerischen Symbole sowie das Unendlichkeitssymbol werden durch ihre entsprechende Ziffer, bzw. durch
            das Unendlichkeitszeichen ersetzt.
        </p>

        <h3 class="clear">Terminale</h3>
        <p>
            Die Terminalsymbole umfassen folgende Zeichen:
        </p>
        <ul class="code">
            <li>"left", "right", "up", "down"</li>
            <li>"stone", "field"</li>
            <li>"2", "3", "4", "5", "6", "7", "8", "9", "&infin;"</li>
            <li>"condition", "endcondition"</li>
            <li>"repeat", "endrepeat"</li>
        </ul>

        <h3>Nichtterminale und Produktionsregeln</h3>
        <p>
            Es gibt folgende Nichtterminale und Produktionsregeln:
        </p>
        <ul class="code">
            <li>Program = { Statement } ;<br></li>
            <li>Statement = (Command | Condition | Loop), { Statement };</li>
            <li>Command = "left" | "right" | "up" | "down" ;</li>
            <li>Condition = "condition", Conditional, { Statement }, "endcondition" ;</li>
            <li>Loop = "repeat", Counter, { Statement }, "endrepeat" ;</li>
            <li>Conditional = "stone" | "field" ;</li>
            <li>Counter = "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "&infin;" ;</li>
        </ul>
        <p>
            Lesehilfe für die Produktionsregeln: Ein gültiges Pictroid-Programm besteht also aus einer beliebigen Anzahl
            von <i>Statements</i>. Diese können ein <i>Command</i>, eine <i>Condition</i> oder einen <i>Loop</i>
            darstellen und von beliebigen weiteren Statements gefolgt werden. Conditions müssen zwingend aus einem
            <i>condition</i>-, einem <i>Conditional</i>- und einem <i>endcondition</i>-Symbol bestehen, dazwischen
            dürfen beliebig viele (auch keine) Statements vorkommen. Loops müssen zwingend aus einem
            <i>repeat</i>-, einem <i>Counter</i>- und einem <i>endrepeat</i>-Symbol bestehen, dazwischen
            dürfen beliebig viele (auch keine) Statements vorkommen. Die Notation sagt ausserdem aus, dass auch ein
            leeres Programm ein gültiges Pictroid-Programm ist.
        </p>

        <h2>Verifizierung / Interpretation eines Programms</h2>
        <p>
            Bei der Verifizierung geht es darum zu entscheiden, ob ein bestimmtes Programm korrekt im Sinne der Sprache
            <i>Pictroid</i> ist. Dabei bezieht sich die Korrektheit nur auf die Syntax des Programms. Ob das Programm
            auch tatsächlich das tut, was dessen Verfasser beabsichtigt, kann leider nicht automatisch verifiziert werden.
        </p>
        <p>
            Wird bei der Verifizierung ein Fehler gefunden, kann zudem ausgesagt werden, an welcher Stelle sich dieser
            befindet. Ausserdem kann auch eine Aussage darüber gemacht werden, von welcher Art der Fehler ist und wie
            er behoben werden kann.
        </p>
        <p>
            Bei der Interpretation sollen die Programmbefehle gelesen und in konkrete Anweisungen für den
            <i>Pictroid</i>-Roboter umgewandelt werden. Da eine erfolgreiche Interpretation ein valides Programm
            voraussetzt, sind Interpretation und Verifizierung stark miteinander verknüpft.
        </p>
        <p>
            Die programmatische Verifizierung von Quellcode kann schnell zu einer komplexen Verschachtelung von
            <i>if</i>-/<i>else</i>-Bedingungen führen, da zu jedem Befehl auch Spezialfälle beachtet werden müssen.
            Dies ist auch bei einer einfachen Sprache wie <i>Pictroid</i> der Fall. So müssen unter anderem folgende
            Bedingungen eingehalten und beim Verifizieren überprüft werden:
        </p>
        <ul>
            <li>Loops und Conditions können beliebig tief ineinander verschachtelt werden. Diese dürfen auch beliebig
                gemischt werden. Beispielsweise darf in einem Loop eine Bedingung gesetzt werden, die darüber
                entscheidet, ob ein innerer Loop ausgeführt wird oder nicht.</li>
            <li>Loops und Conditions müssen immer durch ihr entsprechendes Abschluss-Statement beendet werden.</li>
            <li>Auf ein Condition-Statement muss immer ein Conditional folgen.</li>
            <li>Auf Loop-Statement muss immer ein Counter folgen.</li>
            <li>Conditionals und Counter dürfen an keinen anderen als den vorgesehenen Stellen auftreten.</li>
            <li>Es dürfen keine unbekannten Symbole auftreten.</li>
        </ul>
        <p>
            Zuerst wurde versucht, die Verifizierung mit verschachtelten <i>if</i>-/<i>else</i>-Bedingungen umzusetzen,
            welche die obigen Konditionen überprüfen. Da aber bereits die einfachen Regeln der <i>Pictroid</i>-Sprache zu
            unüberschaubaren und komplexen Codestrukturen führen, habe mich entschieden,
            die Verifizierung mit Hilfe eines <i>PDA</i><span class="footnote">Abkürzung für
            <i>pushdown automaton</i>, englisch für <i>Kellerautomat</i></span> zu implementieren.
        </p>
        <p>
            Ein PDA ist ein theoretisches Konstrukt, das eine Maschine simuliert. Die Maschine kann Zeichen
            verarbeiten, die auf ein <i>unendliches Eingabeband</i> geschrieben sind. Aufgrund dieser Zeichen kann
            die Maschine in unterschiedliche <i>Zustände</i> übergehen. Die Maschine kann lediglich lesend auf das
            unendliche Eingabeband zugreifen. Als Hilfe steht dem PDA allerdings ein <i>Stack</i>
            <span class="footnote">Englisch für <i>Kellerspeicher</i></span> zur Verfügung. Der Stack ist ein Speicher,
            der nach dem LIFO-Prinzip<span class="footnote">Abkürzung für englisch <i>last in, first out</i></span>
            funktioniert. Der PDA kann also Zeichen auf dem Stack ablegen und lesen und diesen so als "Gedächtnis"
            verwenden.<span class="footnote source"><span class="less">Zusammengefasst von: </span>Michael Sipser (1997),
            Introduction to the Theory of Computation<span class="additional">, erschienen bei PWS Publishing,
            ISBN 0-534-94728-X</span></span>
        </p>
        <p>
            Unter Einsatz eines PDA wird die Pictroid-Sprache wie folgt verifiziert:

            <!--TODO: nette grafik für PDA hier irgendwo einfügen-->
        </p>
        <ol>
            <li><p>Beginn: Auf dem Stack befindet sich ein Platzhalter vom Typ <i>Statement</i>.
                Auf dem unendlichen Eingabeband befinden sich die Symbole
                des Programms (beziehungsweise eine textliche Repräsentation davon). Der PDA befindet sich im Zustand
                <i>lesend</i>.</p></li>
            <li><p>Das erste Symbol wird vom Eingabeband eingelesen.</p></li>
            <li>
                <p>Das eingelesene Symbol wird mit demjenigen Symbol verglichen, das sich momentan zuoberst auf dem
                Stack befindet:</p>
                <ul>
                    <li>Handelt es sich beim Symbol auf dem Stack um ein <i>Statement</i>, wird dieses durch eine Folge
                        von Symbolen ersetzt, die gemäss den Regeln der Sprache ein <i>Command</i>, eine
                        <i>Condition</i>, oder ein <i>Loop</i> sein können. Dabei wird diejenige Symbolfolge
                        berücksichtigt, die mit dem momentan vom Eingabeband eingelesenen Symbol beginnt. Danach wird bei
                        <span class="ol-item-reference">3</span> fortgefahren, ohne das nächste Symbol einzulesen.</li>
                    <li>Handelt es sich beim Symbol auf dem Stack nicht um ein <i>Statement</i> und sind die beiden
                        Symbole unterschiedlich, geht der PDA geht in den Zustand <i>ungültig</i> und die Verifikation
                        wird abgebrochen. In diesem Fall wurde zum Beispiel kein <i>Conditional</i> als erstes Symbol
                        nach einer <i>Condition</i> gefunden, was aber laut den Regeln der Sprache notwendig ist.
                        Es wird bei <span class="ol-item-reference">6</span> fortgefahren.</li>
                    <li></li>
                    <li>Handelt es sich beim Symbol auf dem Stack nicht um ein <i>Statement</i> und sind die beiden
                        Symbole gleich, wird das oberste Symbol vom Stack entfernt und das nächste Symbol wird vom
                        Eingabeband gelesen. Es wird bei <span class="ol-item-reference">3</span> fortgefahren.</li>
                    <li>Wurde ein leeres Symbol eingelesen, weil bereits alle definierten Symbole vom Eingabeband
                        gelesen wurden, wird bei <span class="ol-item-reference">4</span> fortgefahren.</li>
                </ul>
            </li>
            <li>
                <p>Wenn alle Symbole vom Eingabeband gelesen wurden, wird der verbleibende Stack analysiert:</p>
                <ul>
                    <li>Wenn sich auf dem Stack nur noch Symbole vom Typ <i>Statement</i> befinden,geht der PDA in
                        den Zustand <i>gültig</i>.</li>
                    <li>Wenn sich auf dem Stack noch Symbole befinden, die nicht vom Typ <i>Statement</i> sind, geht
                        der PDA in den Zustand <i>ungültig</i>. In diesem Fall wurde beispielsweise vergessen, einen
                        <i>repeat</i>-Block mit einem <i>endrepeat</i>-Symbol abzuschliessen, obwohl dies von den
                        Regeln der Sprache verlangt wird.</li>
                </ul>
            </li>
            <li><p>Befindet sich der PDA im Zustand <i>gültig</i>, liegt ein valides Pictroid-Programm vor.
                Befindet er sich hingegen im Zustand <i>ungültig</i>, liegt ein Syntaxfehler vor.</p></li>
        </ol>

        <p>
            Die Verifizierung mittels <i>PDA</i> ist nicht nur überschaubarer, sie ist auch flexibler: Soll nämlich die
            <i>Pictroid</i>-Sprache erweitert werden, muss einfach eine neue Regel zum <i>PDA</i> hinzugefügt werden.
            Bei einer Implementierung mit verschachtelten <i>if</i>-/<i>else</i>-Bedingungen müsste unter Umständen
            die ganze Verifizierung überarbeitet werden.
        </p>
    </div>

    <div class="chapter">
        <h1>Der Prototyp</h1>

        <h2>Funktionsweise</h2>
        <p>
            Nach dem Definieren der Pictroid-Sprache, wurde der Prototyp entwickelt. Dieser besteht aus 5 Teilen:
        </p>
        <ol>
            <li><p>Levelauswahl: Insgesamt stehen fünf Level zur Verfügung.</p></li>
            <li><p>Informationsbereich: Hier wird der Benutzer darüber informiert, was der Pictroid gerade tut.
                Informationen zu Fehlern werden ebenfalls hier angezeigt.</p></li>
            <li><p>Programmierbereich: Bestehend aus den Programmiersymbolen und einem Eingabeband. Mittels Drag'n'Drop
                können die Symbole auf das Eingabeband kopiert werden. Dort können sie auch umgeordnet und wieder
                entfernt werden. Der Einfachheit halber stehen nicht alle Counter-Symbole zur Verfügung, sondern nur
                Primzahlen und das Unendlichkeitssymbol.</p></li>
            <li><p>Steuerung: Alternierend angezeigte Buttons zum Ausführen des Codes, bzw. zum Zurücksetzen des
                Pictroids.</p></li>
            <li><p>Simulationsbereich: Eine Karte mit (je nach Level unterschiedlichen) Hindernissen, auf der sich der
                Pictroid bewegt. Ziel ist es dabei, den Pictroid zum Feld mit dem Öl zu führen.</p></li>
        </ol>
        <figure>
            <img src="img/screenshots/dragndrop.png">
            <figcaption>Programmierung mittels Drag'n'Drop in Level 4</figcaption>
        </figure>
        <p>
            Der im vorherigen Kapitel beschriebene Verifizierer wurde für die Applikation implementiert. Beim
            Drücken des <i>Run Code</i>-Buttons ermittelt der Verifizierer, ob es sich um ein syntaktisch korrektes
            Programm handelt. Wird ein Fehler gefunden, wird dieser im Code auf dem Eingabeband markiert. Im
            Informationsbereich wird ausserdem ein Tip zum Lösen des Problems ausgegeben.
        </p>
        <figure>
            <img src="img/screenshots/error.png">
            <figcaption>Anzeige eines Syntaxfehlers</figcaption>
        </figure>
        <p>
            Wenn keine Syntaxfehler gefunden werden, wird mit dem Ausführen des Codes begonnen. Damit der Benutzer die
            einzelnen Schritte nachvollziehen kann, werden sie mit einer zeitlichen Verzögerung ausgeführt. Während bei
            der Verifikation nur die Syntax überprüft werden kann, können zur Laufzeit durchaus auch semantische Fehler
            erkannt werden. So gibt der Pictroid eine Warnung aus, wenn er in ein Hindernis läuft, oder wenn er nach dem
            Ausführen aller Programmschritte das Öl nicht erreicht hat.
        </p>
        <p>
            Falls der Pictroid während der Code-Ausführung das Ölfeld erreicht, wird die Programmausführung abgebrochen.
            Das Ziel ist erreicht und es wird eine Erfolgsmeldung ausgegeben.
        </p>
        <figure>
            <img src="img/screenshots/hitwall.png">
            <figcaption>Anzeige eines semantischen Fehlers</figcaption>
        </figure>
        <figure>
            <img src="img/screenshots/success.png">
            <figcaption>Pictroid beim Erreichen des Öls</figcaption>
        </figure>

        <h2>Schwierigkeiten</h2>
        <p>
            Im Folgenden werden kurz einige Schwierigkeiten beleuchtet, die beim Implementieren des Prototyps
            angetroffen wurden:
        </p>
        <ul>
            <li>Zeitlich verzögerte Ausführung der einzelnen Instruktionen: Gerade im Zusammenhang mit den
                Pictroid-Schleifen und -Bedingungen stellte dies ein nicht-triviales Problem dar. Das Problem wurde
                mit der Methode <span class="code">runInstructions</span> gelöst, die drei Parameter erhält: Ein Array
                mit allen Instruktionen, der als nächstes auszuführende Instruktionsindex und eine Callback-Funktion.
                Nach jeder ausgeführten Instruktion ruft sich die Funktion rekursiv<span class="footnote">Siehe Glossar
                </span> auf, um den nächsten Schritt auszuführen. Die Callback-Funktion wird dazu benutzt, nach dem
                Ausführen von Schleifen und
                Bedingungsblöcken auf die richtige Instruktion zu springen. Details zu dieser Methode finden sich in der
                Datei <i>js/pictroid-robot.js</i> auf Zeile 228.</li>
            <li>Abbrechen der Code-Ausführung beim Erreichen des Ölfeldes: Unabhängig davon, ob bereits der gesamte Code
                ausgeführt wurde oder nicht, bedeutet das Erreichen des Ölfeldes das Ende des Programms. Das Feld kann
                nur nach dem Ausführen eines Fortbewegungsbefehls (<i>left</i>, <i>right</i>, <i>up</i>, <i>down</i>)
                erreicht werden. Deshalb wird nach jedem solchen Befehl
                überprüft, ob das Ölfeld erreicht ist. Sobald dies der Fall ist, wird die rekursive Programmausführung
                unterbrochen. Details dazu finden sich in der Datei <i>js/pictroid-robot.js</i> auf Zeile 284.</li>
            <li>Unterschiedliche Bedeutung der Fortbewegungsbefehle: Der Befehl <i>left</i> bedeutet "drehe dich nach
                links", wenn der Roboter in eine andere Richtung gedreht ist und "gehe nach links", wenn er bereits
                nach links gedreht ist. Deshalb wird zusätzlich zum aktuellen Feld auch die momentane Orientierung
                abgespeichert. Beim Auffinden eines Fortbewegungsbefehls wird dann überprüft, ob gedreht oder bewegt
                werden soll. Details dazu finden sich in der Datei <i>js/pictroid-robot.js</i> auf Zeile 199.</li>
            <li>Unterschiedliche Levels: Um möglichst wenig Codewiederholung zu verursachen, werden die verschiedenen
                Levels in verschachtelten Arrays gespeichert und das HTML dazu automatisch erstellt. Details dazu finden
                sich in der Datei <i>js/pictroid-robot.js</i> auf Zeile 33.</li>
        </ul>

        <h2>Technischer Hintergrund</h2>
        <p>
            Der Prototyp wurde in HTML, CSS und JavaScript implementiert. Als Implementierungshilfe wurde die
            JavaScript-Bibliothek YUI3<span class="footnote source">
                Yahoo! (2006-2013), YUI3<span class="additional">, Abgerufen am 02.06.2013 von
                http://yuilibrary.com/projects/yui3/</span>
            </span> verwendet. Die grafische Oberfläche basiert auf Bootstrap<span class="footnote source">
                Twitter (2013), Bootstrap<span class="additional">, Abgerufen am 02.06.2013 von
                http://twitter.github.io/bootstrap/</span>
            </span>.
        </p>
        <p>
            Da es sich bei Pictroid um einen Prototyp handelt, können nicht sämtliche Webbrowser untersützt werden. Die
            Applikation wurde jedoch auf den neuesten Versionen von <i>Google Chrome</i> und <i>Mozilla Firefox</i> getestet.
        </p>

        <h2>Mögliche Erweiterungen</h2>
        <p>
            Folgende Erweiterungen sind bei einer zukünftigen Version von Pictroid vorstellbar:
        </p>
        <ul>
            <li>Automatisches Einrücken der Befehle auf dem Eingabeband: Dies würde bei grösseren Programmen helfen, den
                Überblick zu bewahren.</li>
            <li>Funktion, dass Symbolfolgen als "Programm-Schnipsel" abgespeichert werden und an mehreren Stellen
                verwendet werden können.</li>
            <li>Ein Punktesystem, bei dem mit sparsamem Verwenden von Codebefehlen Zusatzpunkte gesammelt werden können.
                Wand-Kollisionen könnten mit Punkteabzug bestraft werden. Ausserdem könnten Punktefelder eingeführt
                werden, um zusäztliche Punkte zu sammeln.</li>
            <li>Bewegliche Hindernisse in der Simulation: Dies würde das Verwenden von Bedingungen fördern.</li>
            <li>Das Schreiben von zwei unterschiedlichen Symbolen auf Felder erlauben und diese Symbole als Conditinals
                einführen. Würde die Simulationskarte dann auf unendliche Höhe und Breite erweitert, könnten beliebige
                Programme geschrieben werden. Die zwei Symbole könnten zum Schreiben von Binärzahlen verwendet werden.
                Pictroid wäre somit turing-vollständig.</li>
        </ul>

        <h2>Installationsanweisungen</h2>
        <p>Pictroid kann unter der URL <a href="http://alainhorner.ch/experiments/pictroid">
            http://alainhorner.ch/experiments/pictroid</a> getestet werden.</p>
        <p>
            Der Sourcecode zum Pictroid-Prototyp ist unter der URL <a href="https://github.com/elHornair/pictroid">
            https://github.com/elHornair/pictroid</a> verfügbar. Zum Installieren
            der Applikation sind folgende Schritte durchzuführen:
        </p>
        <ol>
            <li><p class="code">git checkout git://github.com/elHornair/pictroid.git</p></li>
            <li><p><i>index.html</i> in Google Chrome öffnen. Eine Internetverbindung ist nötig, da YUI nachgeladen
                werden muss.</p></li>
        </ol>

    </div>

    <div class="chapter">
        <h1>Reflexion</h1>

        <h2>Soll- / Ist-Analyse</h2>
        <table>
            <caption>Soll- / Ist-Analyse</caption>
            <tr>
                <th>Soll</th>
                <th>Ist</th>
            </tr>
            <tr>
                <td>Definition einer einfachen Programmiersprache in der Backus-Naur-Form</td>
                <td>Erfüllt, siehe Kapitel 3.3</td>
            </tr>
            <tr>
                <td>Verifizier: Gibt an, ob syntaktisch korrektes Programm vorliegt</td>
                <td>Erfüllt, siehe Kapitel 3.4 und Anwendung</td>
            </tr>
            <tr>
                <td>Interpreter: Arbeitet korrektes Programm schrittweise durch</td>
                <td>Erfüllt, siehe Anwendung</td>
            </tr>
            <tr>
                <td>Anwendung: Der Benutzer kann mit Bildern ein Programm zusammenstellen</td>
                <td>Erfüllt, siehe Anwendung</td>
            </tr>
            <tr>
                <td>Anwendung: Der Benutzer kann sein Programm mittels Drag'n'Drop bearbeiten</td>
                <td>Erfüllt, siehe Anwendung</td>
            </tr>
            <tr>
                <td>Anwendung: Der Benutzer kann ein erstelltes Programm ausführen lassen</td>
                <td>Erfüllt, siehe Anwendung</td>
            </tr>
            <tr>
                <td>Anwendung: Ein Roboter kann ein Programm interpretieren und die entsprechenden Schritte ausführen</td>
                <td>Erfüllt, siehe Anwendung</td>
            </tr>
            <tr>
                <td>Anwendung: Der Roboter hat ein Zielfeld zu erreichen und stoppt automatisch, wenn das Ziel erreicht
                    ist</td>
                <td>Erfüllt, siehe Anwendung</td>
            </tr>
            <tr>
                <td>Anwendung: Die Anwendung erkennt Syntaxfehler und signalisiert diese dem Benutzer</td>
                <td>Erfüllt, siehe Anwendung</td>
            </tr>
            <tr>
                <td>Anwendung: Es stehen drei Levels zur Verfügung, in denen der Benutzer das Programmieren üben kann</td>
                <td>Übertroffen, siehe Anwendung</td>
            </tr>
            <tr>
                <td>Dokumentation der wesentlichen Arbeitsschritte</td>
                <td>Erfüllt, siehe gesamtes Dokument</td>
            </tr>
        </table>

        <h2>Arbeitsprozess</h2>
        <p>
            Die Projektplanung sah vor, 40-50 Stunden in die Seminararbeit zu investieren. Die effektiv
            investierte Zeit lag leicht über dem oberen Rand dieses Rahmens, da die Umsetzung des Prototyps
            etwas unterschätzt wurde. Aus grossem persönlichen Interesse wurde ausserdem auch Funktionalität implementiert,
            die gemäss Aufgabenstellung nicht vorgeschrieben war und der Prototyp wurde mit viel Liebe zum Detail
            umgesetzt. Dies ist eine weitere Erklärung für den etwas zu hohen Aufwand.
        </p>
        <p>
            Das Verfassen der Dokumentation wurde erst gegen Ende der Projektzeit begonnen. Dies führte zu einer sehr
            arbeitsintensiven Schlussphase. Bei einer zukünftigen Projektarbeit wird darauf geachtet werden, die
            jeweiligen Erkenntnisse bereits bei der Durchführung in der Projektdokumentation zu erfassen.
        </p>

        <h2>Persönliches Fazit</h2>
        <p>
            Obwohl ich etwas mehr Zeit in das Projekt investierte als ursprünglich geplant war, bin ich mit dem
            Resultat sehr zufrieden. Ich konnte viel über das Design von Sprachen lernen. Speziell fasziniert hat mich
            die Tatsache, dass mit einem grundsätzlich simplen Gebilde wie dem PDA beliebig komplexe Sprachen
            interpretiert werden können. In diesem Zusammenhang erfuhr ich auch die EBNF-Notation als sehr mächtiges
            Konstrukt. Zudem erhielt ich während dieser Arbeit die Möglichkeit, einen herausfordernden
            Prototypen zu implementieren, mit dem ich mich auch in Zukunft befassen werde.
        </p>
        <p>
            Ich möchte es an dieser Stelle nicht unterlassen, Herrn Beat Seeliger für seine Unterstützung als
            Projektbegleiter zu danken.
        </p>

        <h2>Diverses</h2>
        <p>
            Die vorliegende Dokument wurde mit HTML, CSS und JavaScript erstellt und mit
            Prince<span class="footnote source">
                YesLogic Pty. Ltd. (2013), Prince<span class="additional">, Abgerufen am 01.06.2013 von
                http://www.princexml.com/</span></span> in ein PDF umgewandelt. Sie ist im Originalformat verfügbar unter
            der URL <a href="https://github.com/elHornair/pictroid-doc"> https://github.com/elHornair/pictroid-doc</a>.
            Das Umsetzen der Projektdokumentation mit Webtechnologien stellte eine weitere lehrreiche Herausforderung dar.
        </p>
    </div>

    <div class="chapter">
        <h1>Verzeichnisse</h1>

        <h2>Glossar</h2>
        <p>
            Das Glossar ist alphabetisch geordnet.
        </p>

        <table>
            <caption>Glossar (alphabetisch geordnet)</caption>
            <tr>
                <th>Begriff</th>
                <th>Definition</th>
            </tr>
            <tr>
                <td>Drag'n'Drop</td>
                <td>Beschreibt eine Funktionalität in grafischen Benutzeroberflächen, mit der
                    Benutzer Daten auf natürliche Art und Weise manipulieren können. Ein
                    Objekt kann dabei mit der Maus "gepackt" (klicken und halten) werden.
                    Das Objekt kann dann mittels Mausbewegung verschoben und an einer
                    bestimmten Stelle "abgelegt" (Maustaste loslassen) werden.
                </td>
            </tr>
            <tr>
                <td>Rekursion</td>
                <td>
                    In der Informatik bedeutet Rekursion, dass eine Funktion sich selbst aufruft. Rekursion bietet sich
                    an, wenn zum Berechnen eines Resultats mehrmals die gleichen Schritte mit unterschiedlichen
                    Parametern durchgeführt werden müssen.</td>
            </tr>
            <tr>
                <td>Semantik</td>
                <td>Im Zusammenhang mit Sprachen (sowohl mit natürlichen, als auch mit Programmiersprachen) untersucht
                    die Semantik die Aussage, die mit einem gegebenen Text gemacht wird. Bei Programmiersprachen ist
                    die Aussage das, was mit dem Ausführen des Programms erreicht wird. Semantisch korrekt ist ein
                    Programm, wenn das beabsichtigte Resultat erreicht werden konnte.</td>
            </tr>
            <tr>
                <td>Syntax</td>
                <td>Die Syntax beobachtet im Zusammenhang mit Sprachen (sowohl mit natürlichen, als auch mit
                    Programmiersprachen) den Aufbau eines Textes. Bei einer Programmiersprache ist der Text ein
                    Programm. Als syntaktisch korrekt gilt der Text, wenn er den Regeln entspricht, welche die Sprache
                    definiert.</td>
            </tr>
            <tr>
                <td>Turing-Vollständigkeit</td>
                <td>Ein System wird als turing-vollständig bezeichnet, wenn es universell programmiert werden kann.
                    Universelle Programmierbarkeit bedeutet, dass in diesem System jedes lösbare Problem berechnet
                    werden kann. Programmiersprachen sind in der Regel turing-vollständig.</td>
            </tr>
        </table>

        <h2>Abbildungsverzeichnis</h2>
        <ul id="fig_catalog" class="caption_catalog">
        </ul>

        <h2>Tabellenverzeichnis</h2>
        <ul id="table_catalog" class="caption_catalog">
        </ul>

        <h2>Quellenverzeichnis</h2>
        <ul id="source_catalog">
        </ul>

    </div>

    <div class="chapter">
        <h1>Anhänge</h1>

        <h2>Abstract</h2>
        <p>
            TODO: Write Abstract (+- eine Seite)
        </p>

        <h2>Echtheitserklärung</h2>
        <p>
            Ich erkläre hiermit, dass ich die vorliegende Arbeit selbständig verfasst, alle wörtlichen und
            sinngemäßen Übernahmen als solche gekennzeichnet und keine anderen als die angegebenen
            Quellen benutzt habe.
        </p>
        <p>
            <br>
            <br>
            Alain Horner, 6. Juni 2013
        </p>
    </div>

</div>

TODOs allgemein:
- nette grafik für PDA?

- Alle TODOs durchgehn
- Quellenangaben vervollständigen
- schauen, dass spezielle wörter nur bei der ersten verwendung kursiv sind
- Alles nochmal durchlesen
- cleanup: Seitenumbrüche, Bildunterschriften, Zitate, ...?
- erste seite abschneiden vor abgabe

</body>
</html>
