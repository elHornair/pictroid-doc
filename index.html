<!DOCTYPE html>
<html>
<head>
    <title>Dokumentation Pictroid</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="css/master.css" />
    <script type="text/javascript" src="js/main.js"></script>
</head>

<body>

<div class="dummy"></div>
<div class="frontpage">
    <h1>Pictroid</h1>
    <h2>Programmieren mit Bildern</h2>
    <p>Seminararbeit im Rahmen von "Syntax und Semantik" Im Studiengang Informatik an der ZHAW
       von Alain Horner - Frühjahr 2013</p>
</div>

<h1>Inhaltsverzeichnis</h1>
<ol id="toc">
</ol>

<div id="content">

    <div class="chapter">
        <h1>Projektbeschreibung</h1>

        <h2>Ausgangslage</h2>
        <p>
            Programmieranfänger sind mit in der Praxis verwendeten Programmiersprachen oft überfordert.
            Einerseits sind diese Sprachen sehr komplex, andererseits die Interpreter/Compiler äusserst pingelig.
            Aus eigener Erfahrung verbringt man zu Beginn deshalb viel Zeit damit, sich mit fehlenden Semikola
            und der korrekten Schreibweise von Befehlen herumzuschlagen. Mit einer Programmiersprache, die sich an
            den Bedürfnissen von Programmieranfängern orientiert, könnte deshalb der Einstieg in die Programmierung erleichtert werden.
        </p>
        TODO: bereits existierende lösungen erwähnen. abgrenzung?

        <h2>Ziel der Arbeit</h2>
        <p>
            Das Ziel der Arbeit ist die Entwicklung einer bilderbasierten Programmiersprache und einer Anwendung dieser Sprache. 
        </p>

        <h2>Aufgabenstellung</h2>
        <p>
            Es soll eine einfache Programmiersprache entwickelt werden, in der Anweisungen aus Bildern bestehen.
            Die Sprache soll es Programmiereinsteigern erlauben, mit Hilfe von Bildern einfachen Code zu "schreiben".
            So sollen diese ein grundlegendes Verständnis für das Entwickeln und Interpretieren von Programmcode erlangen.
            Der Student kann so Erfahrung sammeln im Entwickeln und Interpretieren einer Programmiersprache.
        </p>

        <h2>Erwartete Resultate</h2>
        <p>
            Nach Abschluss der Arbeit sollen folgende Resultate vorliegen:
        </p>
        <ul>
            <li>Definition einer einfachen Programmiersprache in der Backus-Naur-Form.</li>
            <li>Verifizier / Syntax-Checker: Gibt an, ob syntaktisch korrektes Programm vorliegt</li>
            <li>Interpreter: Arbeitet korrektes Programm schrittweise durch</li>
            <li>
                Es soll eine Anwedung entwickelt werden, die folgende Anforderungen erfüllt:
                <ul>
                    <li>Der Benutzer kann mit Bildern ein Programm zusammenstellen</li>
                    <li>Der Benutzer kann sein Programm mittels Drag'n'Drop-Funktionalität<span class="footnote">Siehe
                        Glossar</span> bearbeiten</li>
                    <li>Der Benutzer kann ein erstelltes Programm ausführen lassen</li>
                    <li>Der Roboter kann ein Programm interpretieren und die entsprechenden Schritte ausführen</li>
                    <li>Der Roboter stoppt automatisch, wenn das Ziel erreicht ist</li>
                    <li>Die Anwendung erkennt Syntaxfehler und signalisiert diese dem Benutzer</li>
                    <li>Es stehen drei Levels zur Verfügung, in denen der Benutzer das Programmieren üben kann</li>
                </ul>
            </li>
        </ul>

        <h2>Einschränkungen</h2>
        <p>
            Für die vorliegende Arbeit gelten folgende Einschränkungen:
        </p>
        <ul>
            <li>Es soll nicht zwingend eine generische Programmiersprache entwickelt werden. Deshalb besteht nicht der Anspruch, dass die zu
                entwickelnde Sprache turing-vollständig<span class="footnote">Siehe Glossar</span> ist.</li>
            <li>Bei der zu entwickelten Anwendung handelt es sich um einen Prototypen. Die Anwendung kann deshalb in der Benutzerfreundlichkeit
                und der grafischen Aufmachung Lücken aufweisen. Der Prototyp soll lediglich das Funktionsprinzip demonstrieren.</li>
        </ul>

    </div>

    <div class="chapter">
        <h1>Projektplanung</h1>

        <h2>Zeitlicher Rahmen</h2>
        <p>
            Der Kurs wird mit zwei ECTS Punkten honoriert, was einem Aufwand von 50-60 Stunden gleichkommt.
            Davon werden zehn Stunden für Kickoff-Meeting, Koordination und Präsentation abgezogen.
            Somit verbleiben 40-50 Stunden für die Bearbeitung des Themas. Die zur Verfügung stehende Zeit wird wie folgt
            für die Teilarbeiten eingeplant:
        </p>
        <ul>
            <li>Recherchen, Einlesen in das Thema: 5 Stunden</li>
            <li>Entwicklung Sprache: 5 Stunden</li>
            <li>Entwicklung Verifizier/Interpreter: 10 Stunden</li>
            <li>Entwicklung Prototyp: 15 Stunden</li>
            <li>Dokumentation: 15 Stunden</li>
        </ul>

        <h2>Meilensteine</h2>
        <p>
            Folgende Termine sind vorgegeben:
        </p>
        <ul>
            <li>20. März 2013: Kickoff-Meeting</li>
            <li>27. März 2013: Festlegung des Themas</li>
            <li>05. Juni 2013: Abgabe der Seminararbeit</li>
            <li>12. Juni 2013: Präsentation der Seminararbeit</li>
        </ul>
    </div>

    <div class="chapter">
        <h1>Entwicklung der Sprache</h1>

        <h2>Grundlegende Überlegungen</h2>
        <p>

            -> Sprache soll möglichst einfach sein

            TODO: Sagen, was überlegt wurde und erklären, wie die Symbole aussehen (Bilder) -> Syntax / Semantik
                  der Symbole erklären

            - Anweisungen
            - Loops
            - Conditions

            Der Einfachheit halber sollen folgende Features momentan nicht Teil der Sprache:
                - Funktionen
                - Output

            Es ist vorstellbar, dass diese Konzepte zu einem späteren Zeitpunkt in die Sprache integriert werden.

            -> Name: Pictroid
            - durch die farben wird zusammengehörigkeit unterstrichen
        </p>

        <!-- TODO: beschreibungen ausformulieren -->
        <table class="symbols">
            <caption class="caption">Pictroid-Symbole mit Beschreibung</caption>
            <tr>
                <th>Symbol</th>
                <th>Beschreibung</th>
            </tr>
            <tr>
                <td><span class="symbol left"></span></td>
                <td>left</td>
            </tr>
            <tr>
                <td><span class="symbol right"></span></td>
                <td>right</td>
            </tr>
            <tr>
                <td><span class="symbol up"></span></td>
                <td>up</td>
            </tr>
            <tr>
                <td><span class="symbol down"></span></td>
                <td>down</td>
            </tr>
            <tr>
                <td><span class="symbol stone"></span></td>
                <td>stone</td>
            </tr>
            <tr>
                <td><span class="symbol field"></span></td>
                <td>field</td>
            </tr>
            <tr>
                <td><span class="symbol condition"></span></td>
                <td>condition</td>
            </tr>
            <tr>
                <td><span class="symbol endcondition"></span></td>
                <td>endcondition</td>
            </tr>
            <tr>
                <td><span class="symbol repeat"></span></td>
                <td>repeat</td>
            </tr>
            <tr>
                <td><span class="symbol endrepeat"></span></td>
                <td>endrepeat</td>
            </tr>
            <tr>
                <td><span class="symbol two"></span></td>
                <td>two</td>
            </tr>
            <tr>
                <td><span class="symbol infinite"></span></td>
                <td>infinite</td>
            </tr>
        </table>


        <h2>Die Sprache in EBNF-Notation</h2>
        <p>
            - Vorgehen erklären: Zuerst von Hand gezeichnet (als Typ3-Grammatik, oder wie heisst das schon wieder?),
                                 dann mit EBNF-Notation ausgedrückt
            - EBNF-Notation kurz erklären
                - https://de.wikipedia.org/wiki/EBNF


            Begriffe:

            EBNF<span class="footnote source">
                ISO (1996), Extended BNF<span class="additional">, Abgerufen am 28.04.2013 von http://standards.iso.org/ittf/licence.html</span>
            </span>

            Reguläre Grammatik<span class="footnote">Siehe Glossar</span>


            Um die Lesbarkeit der Sprache in der EBNF-Notation zu erhöhen, wurden die grafischen Symbole durch kurze
            Texte ersetzt. Die verwendeten Texte entsprechen wie folgt den oben definierten Symbolen:
        </p>

        <table class="symbols">
            <caption class="caption">Pictroid-Symbole und entsprechende Ersatztexte</caption>
            <tr>
                <th>Symbol</th>
                <th>Ersatztext</th>
                <th>Symbol</th>
                <th>Ersatztext</th>
            </tr>
            <tr>
                <td><span class="symbol left"></span></td>
                <td>left</td>
                <td><span class="symbol right"></span></td>
                <td>right</td>
            </tr>
            <tr>
                <td><span class="symbol up"></span></td>
                <td>up</td>
                <td><span class="symbol down"></span></td>
                <td>down</td>
            </tr>
            <tr>
                <td><span class="symbol stone"></span></td>
                <td>stone</td>
                <td><span class="symbol field"></span></td>
                <td>field</td>
            </tr>
            <tr>
                <td><span class="symbol condition"></span></td>
                <td>condition</td>
                <td><span class="symbol endcondition"></span></td>
                <td>endcondition</td>
            </tr>
            <tr>
                <td><span class="symbol repeat"></span></td>
                <td>repeat</td>
                <td><span class="symbol endrepeat"></span></td>
                <td>endrepeat</td>
            </tr>
        </table>

        <p>
            Die Numerischen Symbole sowie das Unendlichkeitssymbol werden durch ihre entsprechende Ziffer, bzw. durch
            das Unendlichkeitszeichen ersetzt.
        </p>

        <h3 class="clear">Terminalsymbole</h3>
        <p>
            <!-- TODO: andere schrift für code? wenigstens monospace -->
            Counter = "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "&infin;" ;<br>
            Command = "left" | "right" | "up" | "down" ;<br>
            Conditional = "stone" ;
        </p>

        <h3>Nichtterminalsymbole</h3>
        <p>
            <!--TODO: erklären - statement kann auch ins nichts führen -> leeres programm-->
            <!--TODO: erklären - auch NACH loop und condition muss Statement kommen können-->
            Programm = { Statement } ;<br>
            Statement = Command | Condition | Loop ;<br>
            Condition = "condition", Conditional, { Statement }, "endcondition", { Statement } ;<br>
            Loop = "repeat", Counter, { Statement }, "endrepeat", { Statement } ;<br>
        </p>

        <h2>Verifizierung / Interpretation eines Programms</h2>
        <p>
            Bei der Verifizierung geht es darum zu entscheiden, ob ein bestimmtes Programm korrekt im Sinne der Sprache
            <i>Pictroid</i> ist. Dabei bezieht sich die Korrektheit nur auf die
            Syntax<span class="footnote">Siehe Glossar</span> des Programms. Ob das Programm auch tatsächlich das tut,
            was dessen Verfasser beabsichtigt, kann leider nicht automatisch verifiziert werden.
        </p>
        <p>
            Wird bei der Verifizierung ein Fehler gefunden, kann zudem ausgesagt werden, an welcher Stelle sich dieser
            befindet. Ausserdem kann auch eine Aussage darüber gemacht werden, von welcher Art der Fehler ist und wie
            er behoben werden kann.
        </p>
        <p>
            Bei der Interpretation sollen die Programmbefehle gelesen und in konkrete Anweisungen für den
            <i>Pictroid</i>-Roboter umgewandelt werden. Da eine erfolgreiche Interpretation ein valides Programm
            voraussetzt, sind Interpretation und Verifizierung stark miteinander verknüpft.
        </p>
        <p>
            Die programmatische Verifizierung von Quellcode kann schnell zu einer komplexen Verschachtelung von
            <i>if</i>-/<i>else</i>-Bedingungen führen, da zu jedem Befehl auch Spezialfälle beachtet werden müssen.
            Dies ist auch bei einer einfachen Sprache wie <i>Pictroid</i> der Fall. So müssen unter anderem folgende
            Bedingungen eingehalten und beim Verifizieren überprüft werden:
        </p>
        <ul>
            <li>Loops und Conditions können beliebig tief ineinander verschachtelt werden. Diese dürfen auch beliebig
                gemischt werden. Beispielsweise darf in einem Loop eine Bedingung gesetzt werden, die darüber
                entscheidet, ob ein innerer Loop ausgeführt wird oder nicht.</li>
            <li>Loops und Conditions müssen immer durch ihr entsprechendes Abschluss-Statement beendet werden.</li>
            <li>Auf ein Condition-Statement muss immer ein Conditional folgen.</li>
            <li>Auf Loop-Statement muss immer ein Counter folgen.</li>
            <li>Conditionals und Counter dürfen an keinen anderen als den vorgesehenen Stellen auftreten.</li>
            <li>Es dürfen keine unbekannten Symbole auftreten.</li>
        </ul>
        <p>
            Zuerst wurde versucht, die Verifizierung mit verschachtelten <i>if</i>-/<i>else</i>-Bedingungen umzusetzen,
            welche die obigen Konditionen überprüfen. Da aber bereits die einfachen Regeln der <i>Pictroid</i>-Sprache zu
            unüberschaubaren und komplexen Codestrukturen führen, habe mich entschieden,
            die Verifizierung mit Hilfe eines <i>PDA</i><span class="footnote">Abkürzung für
            <i>pushdown automaton</i>, englisch für <i>Kellerautomat</i></span> zu implementieren.
        </p>
        <p>
            Ein PDA ist ein theoretisches Konstrukt, das eine Maschine simuliert. Die Maschine kann Zeichen
            verarbeiten, die auf ein <i>unendliches Eingabeband</i> geschrieben sind. Aufgrund dieser Zeichen kann
            die Maschine in unterschiedliche <i>Zustände</i> übergehen. Die Maschine kann lediglich lesend auf das
            unendliche Eingabeband zugreifen. Als Hilfe steht dem PDA allerdings ein <i>Stack</i>
            <span class="footnote">Englisch für <i>Kellerspeicher</i></span> zur Verfügung. Der Stack ist ein Speicher,
            der nach dem LIFO-Prinzip<span class="footnote">Abkürzung für englisch <i>last in, first out</i></span>
            funktioniert. Der PDA kann also Zeichen auf dem Stack ablegen und lesen und diesen so als "Gedächtnis"
            verwenden.<span class="footnote source"><span class="less">Zusammengefasst von: </span>Michael Sipser (1997),
            Introduction to the Theory of Computation<span class="additional">, erschienen bei PWS Publishing,
            ISBN 0-534-94728-X</span></span>
        </p>
        <p>
            Unter Einsatz eines PDA wird die Pictroid-Sprache wie folgt verifiziert:

            <!--TODO: nette grafik für PDA-->
        </p>
        <ol>
            <li><p>Beginn: Auf dem Stack befindet sich ein Platzhalter vom Typ <i>Statement</i>.
                Auf dem unendlichen Eingabeband befinden sich die Symbole
                des Programms (beziehungsweise eine textliche Repräsentation davon). Der PDA befindet sich im Zustand
                <i>lesend</i>.</p></li>
            <li><p>Das erste Symbol wird vom Eingabeband eingelesen.</p></li>
            <li>
                <p>Das eingelesene Symbol wird mit demjenigen Symbol verglichen, das sich momentan zuoberst auf dem
                Stack befindet:</p>
                <ul>
                    <li>Handelt es sich beim Symbol auf dem Stack um ein <i>Statement</i>, wird dieses durch eine Folge
                        von Symbolen ersetzt, die gemäss den Regeln der Sprache ein <i>Command</i>, eine
                        <i>Condition</i>, oder ein <i>Loop</i> sein können. Dabei wird diejenige Symbolfolge
                        berücksichtigt, die mit dem momentan vom Eingabeband eingelesenen Symbol beginnt. Danach wird bei
                        <span class="ol-item-reference">3</span> fortgefahren, ohne das nächste Symbol einzulesen.</li>
                    <li>Handelt es sich beim Symbol auf dem Stack nicht um ein <i>Statement</i> und sind die beiden
                        Symbole unterschiedlich, geht der PDA geht in den Zustand <i>ungültig</i> und die Verifikation
                        wird abgebrochen. In diesem Fall wurde zum Beispiel kein <i>Conditional</i> als erstes Symbol
                        nach einer <i>Condition</i> gefunden, was aber laut den Regeln der Sprache notwendig ist.
                        Es wird bei <span class="ol-item-reference">6</span> fortgefahren.</li>
                    <li></li>
                    <li>Handelt es sich beim Symbol auf dem Stack nicht um ein <i>Statement</i> und sind die beiden
                        Symbole gleich, wird das oberste Symbol vom Stack entfernt und das nächste Symbol wird vom
                        Eingabeband gelesen. Es wird bei <span class="ol-item-reference">3</span> fortgefahren.</li>
                    <li>Wurde ein leeres Symbol eingelesen, weil bereits alle definierten Symbole vom Eingabeband
                        gelesen wurden, wird bei <span class="ol-item-reference">4</span> fortgefahren.</li>
                </ul>
            </li>
            <li>
                <p>Wenn alle Symbole vom Eingabeband gelesen wurden, wird der verbleibende Stack analysiert:</p>
                <ul>
                    <li>Wenn sich auf dem Stack nur noch Symbole vom Typ <i>Statement</i> befinden,geht der PDA in
                        den Zustand <i>gültig</i>.</li>
                    <li>Wenn sich auf dem Stack noch Symbole befinden, die nicht vom Typ <i>Statement</i> sind, geht
                        der PDA in den Zustand <i>ungültig</i>. In diesem Fall wurde beispielsweise vergessen, einen
                        <i>repeat</i>-Block mit einem <i>endrepeat</i>-Symbol abzuschliessen, obwohl dies von den
                        Regeln der Sprache verlangt wird.</li>
                </ul>
            </li>
            <li><p>Befindet sich der PDA im Zustand <i>gültig</i>, liegt ein valides Pictroid-Programm vor.
                Befindet er sich hingegen im Zustand <i>ungültig</i>, liegt ein Syntaxfehler vor.</p></li>
        </ol>

        <p>
            Die Verifizierung mittels <i>PDA</i> ist nicht nur überschaubarer, sie ist auch flexibler: Soll nämlich die
            <i>Pictroid</i>-Sprache erweitert werden, muss einfach eine neue Regel zum <i>PDA</i> hinzugefügt werden.
            Bei einer Implementierung mit verschachtelten <i>if</i>-/<i>else</i>-Bedingungen müsste unter Umständen
            die ganze Verifizierung überarbeitet werden.
        </p>
    </div>

    <div class="chapter">
        <h1>Der Prototyp</h1>

        <h2>Funktionsweise</h2>
        <p>
            Drag'n'Drop? (sagen, dass nur primzahlen, damit nicht zuviele symbole?)
            Interpretation?
            Steuerung des Roboters?
        </p>

        <h2>Schwierigkeiten</h2>
        <p>
            Auch kurz sagen, wies gelöst wurde:
                - Wenn Ziel gefunden wurde, muss gestoppt werden
                - Nicht alles sofort ausführen: Delay
                - Wenn er Richtung ändert, muss er sich zuerst umdrehen
                - Verschiedene Maps: Array mit Konfiguration pro Level
        </p>

        <h2>Technischer Hintergrund</h2>
        <p>
            Placeholder
        </p>

        <h2>Mögliche Erweiterungen</h2>
        <p>
            - Erweiterung der Sprache: Funktionen (sodass man snippets abspeichern kann), ...
            - Strafpunkte, wenn in Wand reingelaufen wird
            - Hindernisse, die sich bewegen (allgemein dynamische Level)
            - Erlauben, 2 versch. Symbole zu schreiben und diese als conditionals zu verwenden
            - Unendlich grosse map => turing complete
        </p>

        <h2>Installationsanweisungen</h2>
        <p>
            Git checkout sollte alles sein oder? Sagen, dass YUI über internet geladen wird
        </p>
    </div>

    <div class="chapter">
        <h1>Reflexion</h1>

        <h2>Soll- / Ist-Analyse</h2>
        <p>
            TODO: Tabelle
        </p>

        <h2>Arbeitsprozess</h2>
        <p>
            Placeholder
        </p>

        <h2>Persönliches Fazit</h2>
        <p>
            Placeholder
        </p>
    </div>

    <div class="chapter">
        <h1>Verzeichnisse</h1>

        <h2>Glossar</h2>
        <p>
            Das Glossar ist alphabetisch geordnet.
        </p>

        <table>
            <caption class="caption">Glossar (alphabetisch geordnet)</caption>
            <tr>
                <th>Begriff</th>
                <th>Definition</th>
            </tr>
            <tr>
                <td>Drag'n'Drop-Funktionalität</td>
                <td>Beschreibt eine Funktionalität in grafischen Benutzeroberflächen, mit der
                    Benutzer Daten auf natürliche Art und Weise manipulieren können. Ein
                    Objekt kann dabei mit der Maus „gepackt“ (klicken und halten) werden.
                    Das Objekt kann dann mittels Mausbewegung verschoben und an einer
                    bestimmten Stelle „abgelegt“ (Maustaste loslassen) werden.
                </td>
            </tr>
            <tr>
                <td>HTML Canvas 2D Context</td>
                <td>Ein W3C-Standard 34, der skriptbares Rendering von visuellen Daten mittels
                    JavaScript erlaubt. So können Bilder dynamisch im Browser erstellt und
                    manipuliert werden. (TODO: streichen, wenn im text nicht verwendet)
                </td>
            </tr>
            <tr>
                <td>Reguläre Grammatik</td>
                <td>
                    TODO: erklären (nur wenn auch verwendet)
                    <span class="footnote source">
                        Lutz Engelmann (2000), Kleiner Leitfaden Informatik und ihre Anwendung<span class="additional">, erschienen in Berlin, ISBN 3-89517-615-X</span>
                    </span>
                </td>
            </tr>
            <tr>
                <td>Semantik</td>
                <td>
                    TODO: erklären
                </td>
            </tr>
            <tr>
                <td>Syntax</td>
                <td>
                    TODO: erklären
                </td>
            </tr>
            <tr>
                <td>Turing-Vollständigkeit</td>
                <td>TODO: erklären
                </td>
            </tr>
            <tr>
                <td>YUI3</td>
                <td>YUI3 36 ist eine von Yahoo! entwickelte JavaScript-Bibliothek, die Entwickler
                    bei der Implementierung von Webapplikationen unterstützt. YUI3 hebt sich
                    vor allem durch sein fortschrittliches Event- und Modulsystem von
                    Konkurrenzprodukten ab.
                </td>
            </tr>
            <tr>
                <td>...</td>
                <td>...</td>
            </tr>
        </table>
        <!--TODO: tabellenunterschrift hinzufügen-->


        <h2>Abbildungsverzeichnis</h2>
        <p>
            TODO: auto generate -> mit seitenzahlen? (nice2have)
        </p>

        <h2>Tabellenverzeichnis</h2>
        <p>
            TODO: nötig? (wenn ja, dann auch ziele und zielüberprüfung als tabelle)
            TODO: auto generate -> mit seitenzahlen? (nice2have)
        </p>

        <h2>Quellenverzeichnis</h2>
        <ul id="sourceCatalog">
        </ul>

    </div>

    <div class="chapter">
        <h1>Anhänge</h1>

        <h2>Abstract</h2>
        <p>
            Placeholder
        </p>

        <h2>Echtheitserklärung</h2>
        <p>
            Ich erkläre hiermit, dass ich die vorliegende Arbeit selbständig verfasst, alle wörtlichen und
            sinngemäßen Übernahmen als solche gekennzeichnet und keine anderen als die angegebenen
            Quellen benutzt habe.
        </p>
        <p>
            <br>
            <br>
            Alain Horner, 4. Juni 2013
        </p>
    </div>

</div>

TODOs allgemein:
- Alle TODOs durchgehn
- Beat: Falls nicht schon geschehen: Schau Dir unbedingt die Sprache von Robowar an, ich denke die parallelen sind offensichtlich ;) http://en.m.wikipedia.org/wiki/RoboWar -> irgendwo erwähnen? abgrenzung?
- image Captions: styling and numbering
- github repos irgendwo einbauen: doku und app
- Quellenangaben vervollständigen
- glossar komplettieren
- schauen, dass spezielle wörter nur bei der ersten verwendung kursiv sind
- Alles nochmal durchlesen
- cleanup: Seitenumbrüche, Bildunterschriften, Zitate, ...?
- readme, das sagt, wie kompilieren:
    - prince installieren (version?)
    - Command

</body>
</html>
