<!DOCTYPE html>
<html>
<head>
    <title>Dokumentation Pictroid</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link rel="stylesheet" type="text/css" href="css/master.css" />
    <script type="text/javascript" src="js/main.js"></script>
</head>

<body>

<div class="dummy"></div>
<div class="frontpage">
    <h1>Pictroid</h1>
    <h2>Programmieren mit Bildern</h2>
    <p>Seminararbeit im Rahmen von "Syntax und Semantik" Im Studiengang Informatik an der ZHAW
       von Alain Horner - Frühjahr 2013</p>
</div>

<h1>Inhaltsverzeichnis</h1>
<ol id="toc">
</ol>

<div id="content">

    <div class="chapter">
        <h1>Projektbeschreibung</h1>

        <h2>Ausgangslage</h2>
        <p>
            Programmieranfänger sind mit in der Praxis verwendeten Programmiersprachen oft überfordert.
            Einerseits sind diese Sprachen sehr komplex, andererseits die Interpreter/Compiler äusserst pingelig.
            Aus eigener Erfahrung verbringt man zu Beginn deshalb viel Zeit damit, sich mit fehlenden Semikola
            und der korrekten Schreibweise von Befehlen herumzuschlagen. Mit einer Programmiersprache, die sich an
            den Bedürfnissen von Programmieranfängern orientiert, könnte deshalb der Einstieg in die Programmierung
            erleichtert werden.
        </p>
        TODO: bereits existierende lösungen erwähnen. abgrenzung?

        <h2>Ziel der Arbeit</h2>
        <p>
            Das Ziel der Arbeit ist die Entwicklung einer bilderbasierten Programmiersprache und einer Anwendung dieser
            Sprache.
        </p>

        <h2>Aufgabenstellung</h2>
        <p>
            Es soll eine einfache Programmiersprache entwickelt werden, in der Anweisungen aus Bildern bestehen.
            Die Sprache soll es Programmiereinsteigern erlauben, mit Hilfe von Bildern einfachen Code zu "schreiben".
            So sollen diese ein grundlegendes Verständnis für das Entwickeln und Interpretieren von Programmcode erlangen.
            Der Student kann so Erfahrung sammeln im Entwickeln und Interpretieren einer Programmiersprache.
        </p>

        <h2>Erwartete Resultate</h2>
        <p>
            Nach Abschluss der Arbeit sollen folgende Resultate vorliegen:
        </p>
        <ul>
            <li>Definition einer einfachen Programmiersprache in der Backus-Naur-Form.</li>
            <li>Verifizier: Gibt an, ob syntaktisch<span class="footnote">Siehe Glossar</span> korrektes Programm
                vorliegt</li>
            <li>Interpreter: Arbeitet korrektes Programm schrittweise durch</li>
            <li>
                Es soll eine Anwedung entwickelt werden, die folgende Anforderungen erfüllt:
                <ul>
                    <li>Der Benutzer kann mit Bildern ein Programm zusammenstellen</li>
                    <li>Der Benutzer kann sein Programm mittels Drag'n'Drop-Funktionalität<span class="footnote">Siehe
                        Glossar</span> bearbeiten.</li>
                    <li>Der Benutzer kann ein erstelltes Programm ausführen lassen</li>
                    <li>Ein Roboter kann ein Programm interpretieren und die entsprechenden Schritte ausführen.</li>
                    <li>Der Roboter hat ein Zielfeld zu erreichen. Er stoppt automatisch,
                        wenn das Ziel erreicht ist.</li>
                    <li>Die Anwendung erkennt Syntaxfehler und signalisiert diese dem Benutzer.</li>
                    <li>Es stehen drei Levels zur Verfügung, in denen der Benutzer das Programmieren üben kann.</li>
                </ul>
            </li>
        </ul>

        <h2>Einschränkungen</h2>
        <p>
            Für die vorliegende Arbeit gelten folgende Einschränkungen:
        </p>
        <ul>
            <li>Es soll nicht zwingend eine generische Programmiersprache entwickelt werden. Deshalb besteht nicht der
                Anspruch, dass die zu entwickelnde Sprache turing-vollständig<span class="footnote">Siehe Glossar</span>
                ist.</li>
            <li>Bei der zu entwickelten Anwendung handelt es sich um einen Prototypen. Die Anwendung kann deshalb in der
                Benutzerfreundlichkeit und der grafischen Aufmachung Lücken aufweisen. Der Prototyp soll lediglich das
                Funktionsprinzip demonstrieren.</li>
        </ul>

        <h2>Abgrenzung zu RoboWar</h2>
        <p>
            <i>RoboWar</i><span class="footnote source">
                Kevin Hertzberg (2004), RoboWar<span class="additional">, Abgerufen am 11.05.2013 von
                http://robowar.sourceforge.net/RoboWar5/index.html</span>
            </span> ist ein Strategiespiel für mehrere Spieler, in welchem die Spieler jeweils einen Kampfroboter
            steuern. Oberstes Ziel ist dabei das Zerstören der anderen Roboter. RoboWar definiert eine eigene
            Programmiersprache. Mit Instruktionen dieser Sprache werden die Roboter von den Spielern programmiert.
        </p>
        <p>
            Die hier zu entwickelnde Sprache, bzw. der hier zu entwickelnde Prototyp unterscheidet sich von RoboWar in
            folgenden Punkten:
        </p>
        <ul>
            <li>Es soll eine Lernsprache, bzw. eine Lernanwendung entwickelt werden: Auf spielerische Weise soll das
                Programmieren entdeckt werden. RoboWar ist ein Spiel.</li>
            <li>Während sich die zu entwickelnde Sprache an Programmieranfänger richtet, sind für das Spielen von
                RoboWar fortgeschrittene Programmierkenntnisse notwendig.</li>
            <li>Die zu entwickelnde Sprache wird für Einzelspieler konzipiert.</li>
            <li>Während in RoboWar textueller Code zur Programmierung der Roboter verwendet wird, werden
                hier Progamme mit Hilfe von Bildern formuliert.</li>
            <li>Die von Pictroid verwendete Sprache soll deutlich weniger Instruktionen besitzen, als die RoboWar-Sprache
                <span class="footnote source">
                    RoboWiki (2008), Instruction Reference<span class="additional">, Abgerufen am 11.05.2013 von
                    http://robowar.wikia.com/wiki/Instruction_Reference</span>
                    </span>
            </li>
            <li>Das Ziel in der zu entwickelnden Anwendung ist das Erreichen des Zielfeldes. Bei RoboWar sollen die
                feindlichen Roboter zerstört werden.</li>
        </ul>
    </div>

    <div class="chapter">
        <h1>Projektplanung</h1>

        <h2>Zeitlicher Rahmen</h2>
        <p>
            Der Kurs wird mit zwei ECTS Punkten honoriert, was einem Aufwand von 50-60 Stunden gleichkommt.
            Davon werden zehn Stunden für Kickoff-Meeting, Koordination und Präsentation abgezogen.
            Somit verbleiben 40-50 Stunden für die Bearbeitung des Themas. Die zur Verfügung stehende Zeit wird wie folgt
            für die Teilarbeiten eingeplant:
        </p>
        <ul>
            <li>Recherchen, Einlesen in das Thema: 5 Stunden</li>
            <li>Entwicklung Sprache: 5 Stunden</li>
            <li>Entwicklung Verifizier/Interpreter: 10 Stunden</li>
            <li>Entwicklung Prototyp: 15 Stunden</li>
            <li>Dokumentation: 15 Stunden</li>
        </ul>

        <h2>Meilensteine</h2>
        <p>
            Folgende Termine sind vorgegeben:
        </p>
        <ul>
            <li>20. März 2013: Kickoff-Meeting</li>
            <li>27. März 2013: Festlegung des Themas</li>
            <li>05. Juni 2013: Abgabe der Seminararbeit</li>
            <li>12. Juni 2013: Präsentation der Seminararbeit</li>
        </ul>
    </div>

    <div class="chapter">
        <h1>Entwicklung der Sprache</h1>

        <h2>Grundlegende Überlegungen</h2>
        <p>
            Die zu Entwickelnde Sprache wird <i>Pictroid</i> genannt. Pictroid setzt sich aus den beiden englischen
            Wörtern <i>picture</i> und <i>android</i> zusammen. Die Bezeichnung ist deshalb passend, weil mit
            Bildern<span class="footnote">Englisch: Picture</span> ein Roboter<span class="footnote">Englisch:
            Android</span> programmiert werden soll.
        </p>
        <p>
            Gemäss den obigen Zielsetzungen soll die Pictroid-Sprache möglichst einfach sein. Es wurde deshalb überlegt,
            welche wichtigen Programmierkonstrukte für einen Einsteiger fassbar sind und trotzdem ein mächtiges Werkzeug
            in der Programmierung darstellen. Dabei wurden die folgenden drei Konstrukte herausgefiltert:
        </p>
        <ul>
            <li>Anweisungen: Anweisungen sind das wohl wichtigste aller Programmierkonstrukte. Damit können dem
                Computer (bzw. dem Roboter) konkrete Schritte "befohlen" werden. Dieses Konzept ist auch für
                Einsteiger schnell zu verstehen: Ich befehle etwas und der Computer führt es aus.</li>
            <li>Bedingungen: Beim Schreiben eines noch so einfachen Programms kommt man schnell in eine Situation, in
                der man eine Fallunterscheidung vornehmen will. Das Konzept ist deshalb einfach zu verstehen, weil
                vermutlich alle Programmieranfänger Bedingungen aus dem Alltag kennen: Wenn die Ampel rot ist, warte
                ich, wenn die Ampel grün ist, laufe ich.</li>
            <li>Schleifen: Eine wichtige frühe Erkenntnis auf dem frühen Weg zum Programierer ist, dass nicht jede Anweisung
                einzeln erteilt werden muss. Der Computer kann angewiesen werden, Anweisungen zu wiederholen.</li>
        </ul>
        <p>Folgende Konstrukte stellen ebenfalls wichtige Konzepte der Programmierung dar, sollen aber der Einfachheit
            halber nicht Teil der Pictroid-Sprache sein:
        </p>
        <ul>
            <li>Funktionen: Sobald grössere Programme geschrieben werden, entsteht der Wunsch, Code-Sequenzen
                gruppiert abzuspeichern und so wiederverwendbar zu machen. Da mit Pictroid nur sehr kleine Programme
                geschrieben werden sollen, kann jedoch darauf verzichtet werden.</li>
            <li>Ausgabe: Abhängig von der Art des zu lösenden Problems kann eine Rückmeldung des Computers
                unumgänglich sein (z.B. bei einer mathematischen Berechnung). Für Pictroid kann aber darauf verzichtet
                werden, da sich auch ohne eine Ausgabemöglichkeit einfache Programme implementieren lassen.</li>
        </ul>
        <p>
            Es ist vorstellbar, dass diese Konzepte zu einem späteren Zeitpunkt in die Sprache integriert werden.
        </p>

        <h2>Die Sprache Pictroid</h2>
        <p>
            Aufgrund der obigen Überlegungen wurden folgende Symbole für die Pictroid-Sprache definiert. Es wurde darauf
            geachtet, die Symbole so auszuwählen, dass ihre jeweilige Bedeutung leicht damit assoziiert werden kann. Die
            verschiedenen Farben sollen dabei die Ähnlichkeit der Symbole unterstreichen.
        </p>
        <table class="symbols">
            <caption>Pictroid-Symbole mit Beschreibung</caption>
            <tr>
                <th>Symbol</th>
                <th>Semantische Bedeutung<span class="footnote">Siehe Glossar</span></th>
            </tr>
            <tr>
                <td><span class="symbol left"></span></td>
                <td>Weist den Roboter an, sich nach links zu bewegen, bzw. sich nach links zu drehen.</td>
            </tr>
            <tr>
                <td><span class="symbol right"></span></td>
                <td>Weist den Roboter an, sich nach rechts zu bewegen, bzw. sich nach rechts zu drehen.</td>
            </tr>
            <tr>
                <td><span class="symbol up"></span></td>
                <td>Weist den Roboter an, sich nach oben zu bewegen, bzw. sich nach oben zu drehen.</td>
            </tr>
            <tr>
                <td><span class="symbol down"></span></td>
                <td>Weist den Roboter an, sich nach unten zu bewegen, bzw. sich nach unten zu drehen.</td>
            </tr>
            <tr>
                <td><span class="symbol stone"></span></td>
                <td>Steht für einen Stein.</td>
            </tr>
            <tr>
                <td><span class="symbol field"></span></td>
                <td>Steht für ein leeres Feld.</td>
            </tr>
            <tr>
                <td><span class="symbol condition"></span></td>
                <td>Markiert den Beginn einer Bedingung.</td>
            </tr>
            <tr>
                <td><span class="symbol endcondition"></span></td>
                <td>Markiert das Ende einer Bedingung.</td>
            </tr>
            <tr>
                <td><span class="symbol repeat"></span></td>
                <td>Markiert den Beginn einer Schleife.</td>
            </tr>
            <tr>
                <td><span class="symbol endrepeat"></span></td>
                <td>Markiert das Ende einer Schleife.</td>
            </tr>
            <tr>
                <td><span class="symbol two"></span></td>
                <td>Steht für die Zahl <i>zwei</i>. Entsprechend werden Symbole für die Zahlen <i>drei</i> bis
                    <i>neun</i> definiert. Diese sind hier aus Platzgründen nicht aufgelistet.</td>
            </tr>
            <tr>
                <td><span class="symbol infinite"></span></td>
                <td>Steht für eine unendlich grosse Zahl.</td>
            </tr>
        </table>
        <p>
            Pictroid-Bedingungen werden wie folgt formuliert:
        </p>
        <table class="symbols">
            <caption>Bedingungen in Pictroid</caption>
            <tr>
                <th>Symbol</th>
                <th>Erklärung</th>
            </tr>
            <tr>
                <td><span class="symbol condition"></span></td>
                <td>Markiert den Beginn der Bedinung.</td>
            </tr>
            <tr>
                <td><span class="symbol stone"></span></td>
                <td>Definiert, unter welcher Bedingung der Bedingungskörper ausgeführt wird. Die Bedingung bezieht sich
                    immer auf das Feld, das der Roboter betreten würde, wenn er ein Feld geradeaus gehen würde.
                    Alternativ kann das Symbol für ein leeres Feld verwendet werden.</td>
            </tr>
            <tr>
                <td><span class="symbol"></span></td>
                <td>Körper der Bedingung. Hier dürfen beliebige Anweisungen stehen (auch weitere Bedingungen und
                    Schleifen).</td>
            </tr>
            <tr>
                <td><span class="symbol endcondition"></span></td>
                <td>Markiert das Ende der Bedinung.</td>
            </tr>
        </table>
        <p>
            Die Pictroid-Symbole dürfen wie folgt zu Schleifen zusammengefügt werden:
        </p>
        <table class="symbols">
            <caption>Schleifen in Pictroid</caption>
            <tr>
                <th>Symbol</th>
                <th>Erklärung</th>
            </tr>
            <tr>
                <td><span class="symbol repeat"></span></td>
                <td>Markiert den Beginn der Schleife.</td>
            </tr>
            <tr>
                <td><span class="symbol two"></span></td>
                <td>Definiert die Anzahl der auszuführenden Wiederholungen. Alternativ können die Zahlen <i>drei</i>
                    bis <i>neun</i> oder das Symbol für Unendlichkeit verwendet werden.</td>
            </tr>
            <tr>
                <td><span class="symbol"></span></td>
                <td>Körper der Schleife. Hier dürfen beliebige Anweisungen stehen (auch weitere Schleifen und
                    Bedingungen).</td>
            </tr>
            <tr>
                <td><span class="symbol endrepeat"></span></td>
                <td>Markiert das Ende der Schleife.</td>
            </tr>
        </table>
        <p>
            Bedingungen und Schleifen dürfen beliebig ineinander verschachtelt werden. Die Anweisungen zur
            Richtungsänderung dürfen in beliebiger Anzahl ausserhalb von Schleifen und Bedingungen, oder in deren Körper
            vorkommen. Alle anderen als die hier aufgeführten Symbole und Kombinationen sind syntaktisch falsch.
        </p>

        <h2>Pictroid in EBNF-Notation</h2>
        <p>
            Nachdem die grundsätzliche Funktionsweise von Pictroid erarbeitet wurde muss die Sprache formal definiert
            werden. Dazu wird die EBNF-Notation<span class="footnote source">
                ISO (1996), Extended BNF<span class="additional">, Abgerufen am 28.04.2013 von
                http://standards.iso.org/ittf/licence.html</span>
            </span> verwendet. Der Zweck der EBNF-Notation ist es, kontextfreie Grammatiken einheitlich zu beschreiben.
            <span class="footnote source">
                Noam Chomsky (1956), Three models for the description of language<span class="additional">,
                erschienen bei IEEE, ISSN 0096-1000</span>
            </span> Jede Programmiersprache kann als kontextfreie Grammatik aufgefasst werden, also auch Pictroid.
        </p>
        <p>
            In der EBNF-Notation werden einerseits <i>Terminalsymbole</i> beschrieben. Diese umfassen alle Zeichen, die
            im Programmcode der Sprache vorkommen dürfen. Andererseits werden in der EBNF-Notation <i>Nichtterminale</i>
            definiert, die Platzhalter darstellen. Mithilfe von <i>Produktionsregeln</i> können Nichtterminale
            in beliebig lange Folgen von Terminalen und weiteren Nichtterminalen umgewandelt werden. Produktionsregeln
            bestehen immer aus dem linken Teil (dem Nichtterminal), einem Gleichheitszeichen, dem rechten Teil
            (der Produktion) und einem abschliessenden Strichpunkt.
            In der Produktion sind Aneinanderreihungen (dargestellt durch Komma) und Alternativen
            (dargestellt durch vertikalen Strich) von Symbolen erlaubt. Optionale Symbole oder Symbolfolgen werden in
            eckige Klammern gefasst. Symbole oder Symbolfolgen, die beliebig oft (auch nie) wiederholt werden dürfen,
            werden in geschweifte Klammern gefasst. Einfache Klammern dienen der Gruppierung von Symbolfolgen.
        </p>
        <p>
            Um die Lesbarkeit der Sprache in der EBNF-Notation zu erhöhen, werden die grafischen Symbole durch kurze
            Texte ersetzt. Die verwendeten Texte entsprechen wie folgt den zuvor definierten Symbolen:
        </p>
        <table class="symbols">
            <caption>Pictroid-Symbole und entsprechende Ersatztexte</caption>
            <tr>
                <th>Symbol</th>
                <th>Ersatztext</th>
                <th>Symbol</th>
                <th>Ersatztext</th>
            </tr>
            <tr>
                <td><span class="symbol left"></span></td>
                <td>left</td>
                <td><span class="symbol right"></span></td>
                <td>right</td>
            </tr>
            <tr>
                <td><span class="symbol up"></span></td>
                <td>up</td>
                <td><span class="symbol down"></span></td>
                <td>down</td>
            </tr>
            <tr>
                <td><span class="symbol stone"></span></td>
                <td>stone</td>
                <td><span class="symbol field"></span></td>
                <td>field</td>
            </tr>
            <tr>
                <td><span class="symbol condition"></span></td>
                <td>condition</td>
                <td><span class="symbol endcondition"></span></td>
                <td>endcondition</td>
            </tr>
            <tr>
                <td><span class="symbol repeat"></span></td>
                <td>repeat</td>
                <td><span class="symbol endrepeat"></span></td>
                <td>endrepeat</td>
            </tr>
        </table>

        <p>
            Die numerischen Symbole sowie das Unendlichkeitssymbol werden durch ihre entsprechende Ziffer, bzw. durch
            das Unendlichkeitszeichen ersetzt.
        </p>

        <h3 class="clear">Terminale</h3>
        <p>
            Die Terminalsymbole umfassen folgende Zeichen:
        </p>
        <ul class="code">
            <li>"left", "right", "up", "down"</li>
            <li>"stone", "field"</li>
            <li>"2", "3", "4", "5", "6", "7", "8", "9", "&infin;"</li>
            <li>"condition", "endcondition"</li>
            <li>"repeat", "endrepeat"</li>
        </ul>

        <h3>Nichtterminale und Produktionsregeln</h3>
        <p>
            Es gibt folgende Nichtterminale und Produktionsregeln:
        </p>
        <ul class="code">
            <li>Program = { Statement } ;<br></li>
            <li>Statement = (Command | Condition | Loop), { Statement };</li>
            <li>Command = "left" | "right" | "up" | "down" ;</li>
            <li>Condition = "condition", Conditional, { Statement }, "endcondition" ;</li>
            <li>Loop = "repeat", Counter, { Statement }, "endrepeat" ;</li>
            <li>Conditional = "stone" | "field" ;</li>
            <li>Counter = "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "&infin;" ;</li>
        </ul>
        <p>
            Lesehilfe für die Produktionsregeln: Ein gültiges Pictroid-Programm besteht also aus einer beliebigen Anzahl
            von <i>Statements</i>. Diese können ein <i>Command</i>, eine <i>Condition</i> oder einen <i>Loop</i>
            darstellen und von beliebigen weiteren Statements gefolgt werden. Conditions müssen zwingend aus einem
            <i>condition</i>-, einem <i>Conditional</i>- und einem <i>endcondition</i>-Symbol bestehen, dazwischen
            dürfen beliebig viele (auch keine) Statements vorkommen. Loops müssen zwingend aus einem
            <i>repeat</i>-, einem <i>Counter</i>- und einem <i>endrepeat</i>-Symbol bestehen, dazwischen
            dürfen beliebig viele (auch keine) Statements vorkommen. Die Notation sagt ausserdem aus, dass auch ein
            leeres Programm ein gültiges Pictroid-Programm ist.
        </p>

        <h2>Verifizierung / Interpretation eines Programms</h2>
        <p>
            Bei der Verifizierung geht es darum zu entscheiden, ob ein bestimmtes Programm korrekt im Sinne der Sprache
            <i>Pictroid</i> ist. Dabei bezieht sich die Korrektheit nur auf die Syntax des Programms. Ob das Programm
            auch tatsächlich das tut, was dessen Verfasser beabsichtigt, kann leider nicht automatisch verifiziert werden.
        </p>
        <p>
            Wird bei der Verifizierung ein Fehler gefunden, kann zudem ausgesagt werden, an welcher Stelle sich dieser
            befindet. Ausserdem kann auch eine Aussage darüber gemacht werden, von welcher Art der Fehler ist und wie
            er behoben werden kann.
        </p>
        <p>
            Bei der Interpretation sollen die Programmbefehle gelesen und in konkrete Anweisungen für den
            <i>Pictroid</i>-Roboter umgewandelt werden. Da eine erfolgreiche Interpretation ein valides Programm
            voraussetzt, sind Interpretation und Verifizierung stark miteinander verknüpft.
        </p>
        <p>
            Die programmatische Verifizierung von Quellcode kann schnell zu einer komplexen Verschachtelung von
            <i>if</i>-/<i>else</i>-Bedingungen führen, da zu jedem Befehl auch Spezialfälle beachtet werden müssen.
            Dies ist auch bei einer einfachen Sprache wie <i>Pictroid</i> der Fall. So müssen unter anderem folgende
            Bedingungen eingehalten und beim Verifizieren überprüft werden:
        </p>
        <ul>
            <li>Loops und Conditions können beliebig tief ineinander verschachtelt werden. Diese dürfen auch beliebig
                gemischt werden. Beispielsweise darf in einem Loop eine Bedingung gesetzt werden, die darüber
                entscheidet, ob ein innerer Loop ausgeführt wird oder nicht.</li>
            <li>Loops und Conditions müssen immer durch ihr entsprechendes Abschluss-Statement beendet werden.</li>
            <li>Auf ein Condition-Statement muss immer ein Conditional folgen.</li>
            <li>Auf Loop-Statement muss immer ein Counter folgen.</li>
            <li>Conditionals und Counter dürfen an keinen anderen als den vorgesehenen Stellen auftreten.</li>
            <li>Es dürfen keine unbekannten Symbole auftreten.</li>
        </ul>
        <p>
            Zuerst wurde versucht, die Verifizierung mit verschachtelten <i>if</i>-/<i>else</i>-Bedingungen umzusetzen,
            welche die obigen Konditionen überprüfen. Da aber bereits die einfachen Regeln der <i>Pictroid</i>-Sprache zu
            unüberschaubaren und komplexen Codestrukturen führen, habe mich entschieden,
            die Verifizierung mit Hilfe eines <i>PDA</i><span class="footnote">Abkürzung für
            <i>pushdown automaton</i>, englisch für <i>Kellerautomat</i></span> zu implementieren.
        </p>
        <p>
            Ein PDA ist ein theoretisches Konstrukt, das eine Maschine simuliert. Die Maschine kann Zeichen
            verarbeiten, die auf ein <i>unendliches Eingabeband</i> geschrieben sind. Aufgrund dieser Zeichen kann
            die Maschine in unterschiedliche <i>Zustände</i> übergehen. Die Maschine kann lediglich lesend auf das
            unendliche Eingabeband zugreifen. Als Hilfe steht dem PDA allerdings ein <i>Stack</i>
            <span class="footnote">Englisch für <i>Kellerspeicher</i></span> zur Verfügung. Der Stack ist ein Speicher,
            der nach dem LIFO-Prinzip<span class="footnote">Abkürzung für englisch <i>last in, first out</i></span>
            funktioniert. Der PDA kann also Zeichen auf dem Stack ablegen und lesen und diesen so als "Gedächtnis"
            verwenden.<span class="footnote source"><span class="less">Zusammengefasst von: </span>Michael Sipser (1997),
            Introduction to the Theory of Computation<span class="additional">, erschienen bei PWS Publishing,
            ISBN 0-534-94728-X</span></span>
        </p>
        <p>
            Unter Einsatz eines PDA wird die Pictroid-Sprache wie folgt verifiziert:

            <!--TODO: nette grafik für PDA-->
        </p>
        <ol>
            <li><p>Beginn: Auf dem Stack befindet sich ein Platzhalter vom Typ <i>Statement</i>.
                Auf dem unendlichen Eingabeband befinden sich die Symbole
                des Programms (beziehungsweise eine textliche Repräsentation davon). Der PDA befindet sich im Zustand
                <i>lesend</i>.</p></li>
            <li><p>Das erste Symbol wird vom Eingabeband eingelesen.</p></li>
            <li>
                <p>Das eingelesene Symbol wird mit demjenigen Symbol verglichen, das sich momentan zuoberst auf dem
                Stack befindet:</p>
                <ul>
                    <li>Handelt es sich beim Symbol auf dem Stack um ein <i>Statement</i>, wird dieses durch eine Folge
                        von Symbolen ersetzt, die gemäss den Regeln der Sprache ein <i>Command</i>, eine
                        <i>Condition</i>, oder ein <i>Loop</i> sein können. Dabei wird diejenige Symbolfolge
                        berücksichtigt, die mit dem momentan vom Eingabeband eingelesenen Symbol beginnt. Danach wird bei
                        <span class="ol-item-reference">3</span> fortgefahren, ohne das nächste Symbol einzulesen.</li>
                    <li>Handelt es sich beim Symbol auf dem Stack nicht um ein <i>Statement</i> und sind die beiden
                        Symbole unterschiedlich, geht der PDA geht in den Zustand <i>ungültig</i> und die Verifikation
                        wird abgebrochen. In diesem Fall wurde zum Beispiel kein <i>Conditional</i> als erstes Symbol
                        nach einer <i>Condition</i> gefunden, was aber laut den Regeln der Sprache notwendig ist.
                        Es wird bei <span class="ol-item-reference">6</span> fortgefahren.</li>
                    <li></li>
                    <li>Handelt es sich beim Symbol auf dem Stack nicht um ein <i>Statement</i> und sind die beiden
                        Symbole gleich, wird das oberste Symbol vom Stack entfernt und das nächste Symbol wird vom
                        Eingabeband gelesen. Es wird bei <span class="ol-item-reference">3</span> fortgefahren.</li>
                    <li>Wurde ein leeres Symbol eingelesen, weil bereits alle definierten Symbole vom Eingabeband
                        gelesen wurden, wird bei <span class="ol-item-reference">4</span> fortgefahren.</li>
                </ul>
            </li>
            <li>
                <p>Wenn alle Symbole vom Eingabeband gelesen wurden, wird der verbleibende Stack analysiert:</p>
                <ul>
                    <li>Wenn sich auf dem Stack nur noch Symbole vom Typ <i>Statement</i> befinden,geht der PDA in
                        den Zustand <i>gültig</i>.</li>
                    <li>Wenn sich auf dem Stack noch Symbole befinden, die nicht vom Typ <i>Statement</i> sind, geht
                        der PDA in den Zustand <i>ungültig</i>. In diesem Fall wurde beispielsweise vergessen, einen
                        <i>repeat</i>-Block mit einem <i>endrepeat</i>-Symbol abzuschliessen, obwohl dies von den
                        Regeln der Sprache verlangt wird.</li>
                </ul>
            </li>
            <li><p>Befindet sich der PDA im Zustand <i>gültig</i>, liegt ein valides Pictroid-Programm vor.
                Befindet er sich hingegen im Zustand <i>ungültig</i>, liegt ein Syntaxfehler vor.</p></li>
        </ol>

        <p>
            Die Verifizierung mittels <i>PDA</i> ist nicht nur überschaubarer, sie ist auch flexibler: Soll nämlich die
            <i>Pictroid</i>-Sprache erweitert werden, muss einfach eine neue Regel zum <i>PDA</i> hinzugefügt werden.
            Bei einer Implementierung mit verschachtelten <i>if</i>-/<i>else</i>-Bedingungen müsste unter Umständen
            die ganze Verifizierung überarbeitet werden.
        </p>
    </div>

    <div class="chapter">
        <h1>Der Prototyp</h1>

        <h2>Funktionsweise</h2>
        <p>
            Drag'n'Drop? (sagen, dass nur primzahlen, damit nicht zuviele symbole?)
            Interpretation?
            Steuerung des Roboters?
        </p>

        <!-- TODO: replace dummy image-->
        <figure>
            <img src="img/symbols/endcondition.png">
            <figcaption>Ein Testbild</figcaption>
        </figure>

        <figure>
            <img src="img/symbols/endcondition.png">
            <figcaption>Ein weiteres Testbild</figcaption>
        </figure>

        <h2>Schwierigkeiten</h2>
        <p>
            Auch kurz sagen, wies gelöst wurde:
                - Wenn Ziel gefunden wurde, muss gestoppt werden
                - Nicht alles sofort ausführen: Delay
                - Wenn er Richtung ändert, muss er sich zuerst umdrehen
                - Verschiedene Maps: Array mit Konfiguration pro Level
        </p>

        <h2>Technischer Hintergrund</h2>
        <p>
            Placeholder
        </p>

        <h2>Mögliche Erweiterungen</h2>
        <p>
            - Automatisches Einrücken
            - Erweiterung der Sprache: Funktionen (sodass man snippets abspeichern kann), ...
            - Strafpunkte, wenn in Wand reingelaufen wird
            - Hindernisse, die sich bewegen (allgemein dynamische Level)
            - Erlauben, 2 versch. Symbole zu schreiben und diese als conditionals zu verwenden
            - Unendlich grosse map => turing complete (zusammen mit 2 versch. symbole zu schreiben)
            - machen, dass man symbole aufheben kann (zb coins oder so) -> würde das einsetzen von bedingungen fördern
        </p>

        <h2>Installationsanweisungen</h2>
        <p>
            Git checkout sollte alles sein oder? Sagen, dass YUI über internet geladen wird
        </p>
    </div>

    <div class="chapter">
        <h1>Reflexion</h1>

        <h2>Soll- / Ist-Analyse</h2>
        <p>
            TODO: Tabelle (caption nicht vergessen)
        </p>

        <h2>Arbeitsprozess</h2>
        <p>
            Placeholder
        </p>

        <h2>Persönliches Fazit</h2>
        <p>
            Placeholder
        </p>
    </div>

    <div class="chapter">
        <h1>Verzeichnisse</h1>

        <h2>Glossar</h2>
        <p>
            Das Glossar ist alphabetisch geordnet.
        </p>

        <table>
            <caption>Glossar (alphabetisch geordnet)</caption>
            <tr>
                <th>Begriff</th>
                <th>Definition</th>
            </tr>
            <tr>
                <td>Drag'n'Drop-Funktionalität</td>
                <td>Beschreibt eine Funktionalität in grafischen Benutzeroberflächen, mit der
                    Benutzer Daten auf natürliche Art und Weise manipulieren können. Ein
                    Objekt kann dabei mit der Maus „gepackt“ (klicken und halten) werden.
                    Das Objekt kann dann mittels Mausbewegung verschoben und an einer
                    bestimmten Stelle „abgelegt“ (Maustaste loslassen) werden.
                </td>
            </tr>
            <tr>
                <td>HTML Canvas 2D Context</td>
                <td>Ein W3C-Standard 34, der skriptbares Rendering von visuellen Daten mittels
                    JavaScript erlaubt. So können Bilder dynamisch im Browser erstellt und
                    manipuliert werden. (TODO: streichen, wenn im text nicht verwendet)
                </td>
            </tr>
            <tr>
                <td>Semantik</td>
                <td>
                    TODO: erklären
                </td>
            </tr>
            <tr>
                <td>Syntax</td>
                <td>
                    TODO: erklären
                </td>
            </tr>
            <tr>
                <td>Turing-Vollständigkeit</td>
                <td>TODO: erklären
                </td>
            </tr>
            <tr>
                <td>YUI3</td>
                <td>YUI3 36 ist eine von Yahoo! entwickelte JavaScript-Bibliothek, die Entwickler
                    bei der Implementierung von Webapplikationen unterstützt. YUI3 hebt sich
                    vor allem durch sein fortschrittliches Event- und Modulsystem von
                    Konkurrenzprodukten ab.
                </td>
            </tr>
            <tr>
                <td>...</td>
                <td>...</td>
            </tr>
        </table>

        <h2>Abbildungsverzeichnis</h2>
        <ul id="fig_catalog" class="caption_catalog">
        </ul>

        <h2>Tabellenverzeichnis</h2>
        <ul id="table_catalog" class="caption_catalog">
        </ul>

        <h2>Quellenverzeichnis</h2>
        <ul id="source_catalog">
        </ul>

    </div>

    <div class="chapter">
        <h1>Anhänge</h1>

        <h2>Abstract</h2>
        <p>
            Placeholder
        </p>

        <h2>Echtheitserklärung</h2>
        <p>
            Ich erkläre hiermit, dass ich die vorliegende Arbeit selbständig verfasst, alle wörtlichen und
            sinngemäßen Übernahmen als solche gekennzeichnet und keine anderen als die angegebenen
            Quellen benutzt habe.
        </p>
        <p>
            <br>
            <br>
            Alain Horner, 4. Juni 2013
        </p>
    </div>

</div>

TODOs allgemein:
- Alle TODOs durchgehn
- github repos irgendwo einbauen: doku und app
- Quellenangaben vervollständigen
- glossar komplettieren (footnote: jeweils nur beim ersten vorkommen)
- schauen, dass spezielle wörter nur bei der ersten verwendung kursiv sind
- Alles nochmal durchlesen
- cleanup: Seitenumbrüche, Bildunterschriften, Zitate, ...?
- readme, das sagt, wie kompilieren:
    - prince installieren (version?)
    - Command

</body>
</html>
